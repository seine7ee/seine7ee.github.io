<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="python,多进程,multiprocessing,Pool,Process,进程通信,进程同步,多进程读写,">





  <link rel="alternate" href="/atom.xml" title="everything`s cola" type="application/atom+xml">






<meta name="description" content="[Python]基于进程的并行1 subprocess - 生成多余进程 subprocess目的是开始与其他进程交互，即用来生成子进程，并可以通过管道连接它们的输入/输出/错误，以及获得它们的返回值。  subprocess.run()函数是在python 3.5以后被添加的，具体参数列表参见python文档，下面只解释几个常用的参数描述。 subprocess.run(args, captur">
<meta name="keywords" content="python,多进程,multiprocessing,Pool,Process,进程通信,进程同步,多进程读写">
<meta property="og:type" content="article">
<meta property="og:title" content="[Python]基于进程的并行">
<meta property="og:url" content="http://yoursite.com/2020/04/22/Python-基于进程的并行/index.html">
<meta property="og:site_name" content="everything`s cola">
<meta property="og:description" content="[Python]基于进程的并行1 subprocess - 生成多余进程 subprocess目的是开始与其他进程交互，即用来生成子进程，并可以通过管道连接它们的输入/输出/错误，以及获得它们的返回值。  subprocess.run()函数是在python 3.5以后被添加的，具体参数列表参见python文档，下面只解释几个常用的参数描述。 subprocess.run(args, captur">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-04-22T13:53:08.269Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Python]基于进程的并行">
<meta name="twitter:description" content="[Python]基于进程的并行1 subprocess - 生成多余进程 subprocess目的是开始与其他进程交互，即用来生成子进程，并可以通过管道连接它们的输入/输出/错误，以及获得它们的返回值。  subprocess.run()函数是在python 3.5以后被添加的，具体参数列表参见python文档，下面只解释几个常用的参数描述。 subprocess.run(args, captur">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/04/22/Python-基于进程的并行/">





  <title>[Python]基于进程的并行 | everything`s cola</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">everything`s cola</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/22/Python-基于进程的并行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="seine7ee">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="everything`s cola">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[Python]基于进程的并行</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-22T21:28:30+08:00">
                2020-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python基础/" itemprop="url" rel="index">
                    <span itemprop="name">Python基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Python-基于进程的并行"><a href="#Python-基于进程的并行" class="headerlink" title="[Python]基于进程的并行"></a>[Python]基于进程的并行</h1><h2 id="1-subprocess-生成多余进程"><a href="#1-subprocess-生成多余进程" class="headerlink" title="1 subprocess - 生成多余进程"></a>1 subprocess - 生成多余进程</h2><blockquote>
<p>subprocess目的是开始与其他进程交互，即用来生成子进程，并可以通过管道连接它们的输入/输出/错误，以及获得它们的返回值。</p>
</blockquote>
<p>subprocess.run()函数是在python 3.5以后被添加的，具体参数列表参见python文档，下面只解释几个常用的参数描述。</p>
<p><code>subprocess.run</code>(<em>args, capture_out=False, shell=False, timeout=None, check=False</em>)</p>
<ul>
<li>作用： 调用子进程，并返回进程状态码，如果一个进程被执行并结束，则返回0.</li>
</ul>
<blockquote>
<p>params:</p>
<ul>
<li><strong>args</strong>：指令 ，如果<strong>shell=False</strong>，则使用python解析器解析(等同于<code>subprocess.call(args)</code>)，args为<strong>命令参数列表</strong>，如果<strong>shell=True</strong>，则使用shell自己解析，则args为<strong>命令字符串</strong>；</li>
<li>capture_out：如果capture_out设为true，stdout和stderr将会被捕获；</li>
<li>timeout：见文档；</li>
<li><strong>check</strong>：如果check设为true，并且进程以非零状态码退出，一个CalledProcessError异常将会被抛出。 </li>
</ul>
</blockquote>
<h2 id="2-Multiprocessing-基于进程的并行"><a href="#2-Multiprocessing-基于进程的并行" class="headerlink" title="2  Multiprocessing - 基于进程的并行"></a>2  Multiprocessing - 基于进程的并行</h2><p>在Unix/Linux系统中提供了一个fork()函数，它比较特殊，普通函数调用一次，返回一次，而fork()函数调用一次，返回两次，因为操作系统会自动地把当前系统复制一份（也就是子进程），然后在父进程和子进程中分别返回. 其中，父进程返回子进程号，而子进程永远返回0.</p>
<h3 id="I-上下文和启动方法"><a href="#I-上下文和启动方法" class="headerlink" title="I. 上下文和启动方法"></a>I. 上下文和启动方法</h3><p>根据不同的平台，multiprocessing支持<strong>三种启动进程</strong>的方法. 这些启动方法有：</p>
<ol>
<li><p>spawn</p>
<p>父进程启动一个新的Python解释器进程，子进程只会继承那些运行进程对象的run()方法所需的资源，相对于使用fork或forserver，使用这个方法启动进程相当慢。可在Unix和Windows上使用，是在windows上的默认设置。</p>
</li>
<li><p>fork</p>
<p>父进程使用os.fork()来产生Python解释器分叉，只存在于Unix（Unix中的默认值）。</p>
</li>
<li><p>forkserver</p>
<p>程序启动并选择<em> forkserver </em> 启动方法时，将启动服务器进程。可在Unix平台上使用。</p>
</li>
</ol>
<p>启动方法：</p>
<p>可以使用<code>multiprocessing.set_start_methond(&#39;spawn&#39;)</code>或<code>multiprocessing.get_context(&#39;spawn&#39;)</code>启动。</p>
<blockquote>
<ol>
<li>在程序中set_start_method()不应该被多次调用；</li>
<li>或者，可以使用get_context()来获取上下文对象（获取一个按指定启动方法启动的multiprocessing对象）。<strong>上下文对象与多处理模块具有相同的API，并允许在统一程序中使用多个启动方法</strong>。</li>
</ol>
</blockquote>
<h3 id="II-进程间通信"><a href="#II-进程间通信" class="headerlink" title="II. 进程间通信"></a>II. 进程间通信</h3><p>进程间可以使用Queue或者Pipe来进行通信。</p>
<h4 id="1-Queue用来在多个进程间进行通信"><a href="#1-Queue用来在多个进程间进行通信" class="headerlink" title="1. Queue用来在多个进程间进行通信"></a>1. Queue用来在多个进程间进行通信</h4><p>Queue用来在多个进程间进行通信，Queue主要使用两个方法，get()和put().</p>
<blockquote>
<p><code>put(obj [, block=True [, timeout=None]])</code>：</p>
<ul>
<li>将obj放入到队列中；</li>
<li>如果可选参数block=True，(1)并且timeout是None，将会阻塞当前进程，直到有空的缓冲槽；(2)如果timeout是正数，将会在最多阻塞了timeout秒后，如果还是没有可用的缓冲槽时将抛出queue.Full异常。</li>
<li>如果可选参数block=False(此时timeout参数会被忽略掉)，仅当有可用缓冲槽时才放入队列中，否则抛出queue.Full异常。</li>
</ul>
<p>get([block [, timeout]]):</p>
<ul>
<li>从队列中取出并返回对象；</li>
<li>block和timeout的作用与put类似，详见python文档。</li>
</ul>
</blockquote>
<p>下面是一个代码实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_process</span><span class="params">(q, tokens)</span>:</span></span><br><span class="line">    <span class="comment"># 需要执行的子进程</span></span><br><span class="line">    print(<span class="string">"Write Process`s writing, process id is &#123;:d&#125;."</span>.format(os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        q.put(token)</span><br><span class="line">        print(<span class="string">'put &#123;:s&#125; to the queue.'</span>.format(token))</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_process</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">"Read Process`s reading, process id is &#123;:d&#125;."</span>.format(os.getpid()))</span><br><span class="line">    <span class="comment"># while not q.empty():</span></span><br><span class="line">    <span class="comment">#     token = q.get()</span></span><br><span class="line">    <span class="comment">#     print("get &#123;:s&#125; from the queue.".format(token))</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        token = q.get()</span><br><span class="line">        print(<span class="string">"get &#123;:s&#125; from the queue."</span>.format(token))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    q = multiprocessing.Queue()</span><br><span class="line">    <span class="comment"># 实例化子进程</span></span><br><span class="line">    pw1 = Process(target=write_process, args=(q, [<span class="string">'t1'</span>, <span class="string">'t2'</span>, <span class="string">'t3'</span>]))</span><br><span class="line">    pw2 = Process(target=write_process, args=(q, [<span class="string">'t4'</span>, <span class="string">'t5'</span>]))</span><br><span class="line">    pr = Process(target=read_process, args=(q, ))</span><br><span class="line">    <span class="comment"># 开始执行子进程</span></span><br><span class="line">    pw1.start()</span><br><span class="line">    pw2.start()</span><br><span class="line">    pr.start()</span><br><span class="line">    pw1.join()</span><br><span class="line">    pw2.join()</span><br><span class="line">    <span class="comment"># pr.join() 如果read_process使用 not q.empty()作为判断条件，由于多进程的异步性，会有元素无法从队列中取出</span></span><br><span class="line">    <span class="comment"># read_process里是一个死循环，只能强制终止</span></span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Write Process`s writing, process id <span class="keyword">is</span> <span class="number">20408.</span>Read Process`s reading, process id <span class="keyword">is</span> <span class="number">23268.</span></span><br><span class="line"></span><br><span class="line">Write Process`s writing, process id <span class="keyword">is</span> <span class="number">19232.</span></span><br><span class="line">put t1 to the queue.put t4 to the queue.</span><br><span class="line"></span><br><span class="line">get t1 <span class="keyword">from</span> the queue.</span><br><span class="line">get t4 <span class="keyword">from</span> the queue.</span><br><span class="line">put t5 to the queue.get t5 <span class="keyword">from</span> the queue.</span><br><span class="line"></span><br><span class="line">put t2 to the queue.</span><br><span class="line">get t2 <span class="keyword">from</span> the queue.</span><br><span class="line">put t3 to the queue.</span><br><span class="line">get t3 <span class="keyword">from</span> the queue.</span><br></pre></td></tr></table></figure>
<p><strong>扩展</strong></p>
<blockquote>
<p>在最近的项目中碰到了multiprocessing.SimpleQueue，记录一下.</p>
<p><strong>class multiprocessing.SimpleQueue</strong></p>
<p>- 这是一个简化的Queue类的实现，很像带锁的Pipe.</p>
<ol>
<li><p>empty(）</p>
<p>- 如果队列为空则返回True，否则返回False.</p>
</li>
<li><p>get()</p>
<p>- 从队列中移除并返回一个对象.</p>
</li>
<li><p>put(item)</p>
<p>- 将item放入队列.</p>
</li>
</ol>
</blockquote>
<h4 id="2-Pipe常用来在两个进程间通信"><a href="#2-Pipe常用来在两个进程间通信" class="headerlink" title="2. Pipe常用来在两个进程间通信"></a>2. Pipe常用来在两个进程间通信</h4><p>Pipe常用来在两个进程间通信，两个进程分别位于管道的两端.</p>
<blockquote>
<p><code>multiprocessing.Pipe([duplex=True])</code></p>
<p>- 返回一对Connection对象，(conn1, conn2)分别表示管道的两端;</p>
<p>- 如果duplex被置为True，那么该管道是双向的，如果为False，那么该管道是单向的，即conn1只能用于接收消息，conn2只能用于发送消息.</p>
<p>管道是将一系列标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入.</p>
</blockquote>
<p>代码实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="comment"># 要执行的子进程</span></span><br><span class="line">    pipe.send(<span class="string">"This is a message."</span>)</span><br><span class="line">    pipe.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    (send_pipe, recv_pipe) = Pipe()</span><br><span class="line">    <span class="comment"># 实例化进程</span></span><br><span class="line">    p = Process(target=send, args=(send_pipe, ))</span><br><span class="line">    <span class="comment"># 执行子进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(recv_pipe.recv())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a message.</span><br></pre></td></tr></table></figure>
<p>管道同时进行发送信息和接收信息（双工通信）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="comment"># 要执行的子进程</span></span><br><span class="line">    pipe.send(<span class="string">"This is a message."</span>)                <span class="comment"># 管道发送信息</span></span><br><span class="line">    pipe.close()                                   <span class="comment"># 关闭管道</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sender</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(&#123;<span class="string">"name"</span>: <span class="string">"sender"</span>, <span class="string">"content"</span>: <span class="string">"Do you copy?"</span>&#125;)</span><br><span class="line">    recv = pipe.recv()</span><br><span class="line">    print(<span class="string">"sender got: "</span>, recv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    (send_pipe, recv_pipe) = Pipe()                 <span class="comment"># Pipe()返回一对管道实例</span></span><br><span class="line">    s = Process(target=sender, args=(send_pipe, ))  <span class="comment"># 实例化sender进程</span></span><br><span class="line">    s.start()</span><br><span class="line">    recv = recv_pipe.recv()                         <span class="comment"># recv_pipe是一个Pipe管道，可以接收send_pipe发送过来的消息</span></span><br><span class="line">    print(<span class="string">"recver got: "</span>, recv)                     <span class="comment"># 打印recv_pipe接收的来自send_pipe的消息</span></span><br><span class="line">    recv_pipe.send(<span class="string">"roger that."</span>)                   <span class="comment"># recv_pipe同时又能发送消息</span></span><br><span class="line">    s.join()</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">recver got:  &#123;&apos;name&apos;: &apos;sender&apos;, &apos;content&apos;: &apos;Do you copy?&apos;&#125;</span><br><span class="line">sender got:  roger that.</span><br></pre></td></tr></table></figure>
<h3 id="III-进程之间的同步"><a href="#III-进程之间的同步" class="headerlink" title="III. 进程之间的同步"></a>III. 进程之间的同步</h3><p>在进行并发编程时，通常最好<strong>尽量避免使用共享状态</strong>，使用多个进程时尤其如此。</p>
<p>但是，如果真的需要使用一些共享数据，那么<code>multiprocessing</code>提供了两种方法。</p>
<h4 id="1-共享内存"><a href="#1-共享内存" class="headerlink" title="1. 共享内存"></a>1. 共享内存</h4><p>可以使用<code>Value</code>或<code>Array</code>将<strong>数据存储在共享内存映射</strong>中， <code>Value</code>和<code>Array</code>在python3.7中只能供<code>multiprocessing.Process</code>使用，而不能被<code>multiprocessing.Pool</code>使用，</p>
<p><code>multiprocessing.Value</code>和<code>multiprocessing.Array</code>是共享<code>ctypes</code>对象</p>
<ol>
<li><p><strong>Value</strong>(typecode_or_type, <em>args, lock=True</em>)</p>
<p><strong>属性和方法</strong>：</p>
<ul>
<li>value： 获取值</li>
<li>get_lock()：获取锁对象</li>
<li>acquire/release：获取锁/释放锁</li>
</ul>
<p><strong>介绍</strong>：</p>
<p>返回一个从共享内存上创建的ctypes对象，可以通过<code>Value</code>的<code>value</code>属性访问这个对象本身。</p>
<p><code>typecode_or_type</code>: 指明了返回的对象类型， 对象类型如<strong>(附录)Table 1</strong>所示。</p>
<p>如果<code>lock</code>是<code>True</code>， 将会新建一个递归锁用于同步对于此值的访问操作，如果<code>lock</code>是<code>Lock</code>或者<code>RLock</code>对象，那么传入的锁将会用于同步对这个值的访问操作，如果<code>lock</code>是<code>False</code>，那么对这个对象的访问将没有锁保护，也就是说这个变量不是进程安全的。</p>
<p>对于<code>+=</code>这样的操作会引发独立的读操作和写操作，也就是说这类操作符不具有原子性。所以，如果你想让递增操作具有原子性，这样的方式并不能达到要求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">couter.value += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>假设共享对象内部关联的锁是递归锁(默认情况下)，为了让这样的操作具有原子性，那么可以为该操作加锁，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> couter.get_lock():</span><br><span class="line">    counter.value += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock, Value</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_sum</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        val.value += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    val = Value(<span class="string">'i'</span>, <span class="number">0</span>)</span><br><span class="line">    process_list = [Process(target=func_sum, args=(val, )) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> process_list:</span><br><span class="line">        process.start()</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> process_list:</span><br><span class="line">        process.join()</span><br><span class="line">    print(val.value)     <span class="comment"># val.value每次得出的结果都不一样，但不等于100</span></span><br></pre></td></tr></table></figure>
<p>我们通过创建一个共享对象<code>Value</code>，希望经过100次迭代后，其值能够达到100，但实际的输出并不是100，<code>Value</code>的参数中<code>lock</code>默认是True，意味着将会创建一个递归锁对象用于同步访问控制，然而，要想实现真正的同步访问控制，需要实现获取这个锁，经过修改，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_with_lock</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">with</span> val.get_lock():</span><br><span class="line">            val.value += <span class="number">1</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        也可以这样获得锁：</span></span><br><span class="line"><span class="string">        if val.acquire():</span></span><br><span class="line"><span class="string">        	val.value += 1</span></span><br><span class="line"><span class="string">        val.release()</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    val = Value(<span class="string">'i'</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># process_list = [Process(target=func_sum, args=(val, )) for i in range(10)]</span></span><br><span class="line">    process_list = [Process(target=func_with_lock, args=(val,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> process_list:</span><br><span class="line">        process.start()</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> process_list:</span><br><span class="line">        process.join()</span><br><span class="line">    print(val.value)   <span class="comment"># 100</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>Array</strong>(<em>typecode_or_type, size_or_initializer, \</em>, lock=True*)</p>
<p>从共享内存中申请并返回一个具有ctypes类型的数组对象。</p>
<p><code>typecode_or_type</code> 指明了返回的数组中的元素类型: 它可能是一个 <code>ctypes</code> 类型或者 <code>array</code> 模块中每个类型对应的单字符长度的字符串。 </p>
<p>如果 <code>size_or_initializer</code> 是一个整数，那就会当做数组的长度，并且整个数组会初始化为0。否则，如果 <code>size_or_initializer</code> 会被当成一个序列用于初始化数组中的每一个元素，并且会根据元素个数自动判断数组的长度。</p>
<p>也就是说，<code>size_or_initializer</code> 只能是两种情况：</p>
<ol>
<li>是一个整数；</li>
<li>是一个序列，如<code>list</code>，<code>tuple</code>， <code>range</code>（python的序列类型就这三种）。</li>
</ol>
</li>
</ol>
<h4 id="2-服务器进程"><a href="#2-服务器进程" class="headerlink" title="2. 服务器进程"></a>2. 服务器进程</h4><p>由 <code>Manager()</code> 返回的管理器对象控制一个服务器进程，该进程保存Python对象并允许其他进程使用代理操作它们。<strong><code>multiprocessing.Pool</code>只能使用<code>Manager()</code>来实现进程同步。</strong></p>
<p><code>Manager()</code> 返回的管理器支持类型： <code>list 、 dict 、 Namespace 、 Lock 、 RLock 、 Semaphore 、 BoundedSemaphore 、 Condition 、 Event 、 Barrier 、 Queue 、 Value 和 Array</code> 。</p>
<p>使用示例见<strong>1.5.5 多进程读写文件</strong></p>
<h2 id="3-启动大量子进程"><a href="#3-启动大量子进程" class="headerlink" title="3 启动大量子进程"></a>3 启动大量子进程</h2><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程。</p>
<blockquote>
<p>class multiprocessing.Pool([process [, initializer [, initargs [, maxtasksperchild [ , context]]]]])</p>
<ul>
<li><p>一个进程池对象，它控制可以提交作业的工作进程池。支持带有超时和回调的异步结果，以及一个并行的map实现；</p>
</li>
<li><p>params:</p>
<p>- process: 使用的工作进程数，如果process=None，则使用os.cpu_count()返回的值</p>
</li>
<li><p>funcs：</p>
<ol>
<li><p><code>apply</code>(<em>func</em>[, <em>args</em>[, <em>kwds</em>]])</p>
<p>使用args参数以及kwds命名参数调用func，它会返回结果前阻塞。这种情况下，apply_async()更适合并行化工作，另外func只会在一个进程池中的一个工作进程中执行。</p>
</li>
<li><p><code>apply_async</code>(<em>func</em>[, <em>args</em>[, <em>kwds</em>[, <em>callback</em>[, <em>error_callback</em>]]]])</p>
<p><code>apply()</code>方法的变种，返回一个结果对象。</p>
</li>
<li><p><code>join()</code></p>
<p>等待工作进程结束，<strong>调用<code>join()</code>前必须先调用<code>close()</code>或者<code>terminate()</code></strong></p>
</li>
</ol>
</li>
</ul>
</blockquote>
<p>代码实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    p.close()                                         <span class="comment"># close() - 阻止后续任务提交到进程池，当所有任务执行完成后，工作进程会退出 </span></span><br><span class="line">    p.join()                                          <span class="comment"># join() - 等待工作进程结束，调用join()前必须先调用close()或者terminate()</span></span><br><span class="line">    print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parent process <span class="number">26060.</span></span><br><span class="line">Waiting <span class="keyword">for</span> all subprocesses done...</span><br><span class="line">Run task <span class="number">0</span> (<span class="number">21004</span>)...</span><br><span class="line">Run task <span class="number">1</span> (<span class="number">24740</span>)...</span><br><span class="line">Run task <span class="number">2</span> (<span class="number">13948</span>)...</span><br><span class="line">Run task <span class="number">3</span> (<span class="number">25100</span>)...</span><br><span class="line">Task <span class="number">2</span> runs <span class="number">0.54</span> seconds.</span><br><span class="line">Run task <span class="number">4</span> (<span class="number">13948</span>)...</span><br><span class="line">Task <span class="number">0</span> runs <span class="number">0.93</span> seconds.</span><br><span class="line">Task <span class="number">1</span> runs <span class="number">0.98</span> seconds.</span><br><span class="line">Task <span class="number">3</span> runs <span class="number">1.79</span> seconds.</span><br><span class="line">Task <span class="number">4</span> runs <span class="number">1.57</span> seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure>
<h2 id="4-Pool和Process的区别"><a href="#4-Pool和Process的区别" class="headerlink" title="4 Pool和Process的区别"></a>4 Pool和Process的区别</h2><ol>
<li><code>multiprocessing.Pool</code>可以批量启动子进程，而<code>multiprocessing.Process</code>一次只能启动一个进程，当然<code>multiprocessing.Process</code>可以使用列表生成式来创建一个子进程列表；</li>
<li><code>Process</code>可以直接使用<code>Queue</code>来进行进程间的通信，而<code>Pool</code>如果想实现进程间的通信，只能使用共享内存来实现，即使用<code>Manager().Queue</code>来实现进程间的通信；</li>
<li><code>Process</code>可以直接使用共享内存<code>Array</code>和<code>Value</code>来实现进程同步，而<code>Pool</code>不能直接使用<code>Array</code>和<code>Value</code>，<code>Pool</code>要想实现进程同步、进程通信，可以使用<code>multiprocessing.Manager</code>。</li>
</ol>
<h2 id="5-多进程读写文件-VS-单进程读写文件"><a href="#5-多进程读写文件-VS-单进程读写文件" class="headerlink" title="5 多进程读写文件 VS 单进程读写文件"></a>5 多进程读写文件 VS 单进程读写文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Array, RLock, Value, Manager</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_read</span><span class="params">(multi_val, arr, arr_len, interval, rlock)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    多进程分块读数组内容，并返回一个interval长度的字符串</span></span><br><span class="line"><span class="string">    :param multi_arr:</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :param arr_len:</span></span><br><span class="line"><span class="string">    :param pid:</span></span><br><span class="line"><span class="string">    :param interval:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> rlock:</span><br><span class="line">        start_idx = multi_val.value</span><br><span class="line">        end_idx = (start_idx + interval) <span class="keyword">if</span> (start_idx + interval) &lt; arr_len <span class="keyword">else</span> arr_len</span><br><span class="line">        multi_val.value = end_idx</span><br><span class="line"></span><br><span class="line">    cur_idx = start_idx</span><br><span class="line">    string_value = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> cur_idx &lt; end_idx:</span><br><span class="line">        string_value += (str(arr[cur_idx]) + <span class="string">'\n'</span>)</span><br><span class="line">        cur_idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> string_value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_multiread</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    向文件中写字符串</span></span><br><span class="line"><span class="string">    该函数是一个回调函数，其接收的参数为 multi_read 返回的值</span></span><br><span class="line"><span class="string">    :param s:</span></span><br><span class="line"><span class="string">    :param file_path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    file_path = <span class="string">r"C:\DevelopWorkspace\test\multi_read_multi_write_10_billion.txt"</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'a+'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_read_multi_write</span><span class="params">(res, multi_read, write_multiread)</span>:</span></span><br><span class="line">    workers = multiprocessing.cpu_count()</span><br><span class="line">    p = Pool(workers)</span><br><span class="line">    manager = Manager()</span><br><span class="line">    rlock = manager.RLock()</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    logger.info(<span class="string">'start time: &#123;&#125;'</span>.format(start))</span><br><span class="line">    <span class="keyword">for</span> sub_list <span class="keyword">in</span> res:</span><br><span class="line">        length = len(sub_list)</span><br><span class="line">        interval = math.ceil(length / workers)</span><br><span class="line">        multi_val = manager.Value(<span class="string">'l'</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 异步执行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(workers):</span><br><span class="line">            p.apply_async(multi_read, args=(multi_val, sub_list, length, interval, rlock), callback=write_multiread)</span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment"># 单进程读单进程写</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_read_single_write</span><span class="params">(res)</span>:</span></span><br><span class="line">    file_path = <span class="string">r"C:\DevelopWorkspace\test\single_read_single_write_10_billion.txt"</span></span><br><span class="line">    <span class="keyword">for</span> sub <span class="keyword">in</span> res:</span><br><span class="line">        string_value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> sub:</span><br><span class="line">            string_value += str(ele) + <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">with</span> open(file_path, <span class="string">'a+'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(string_value)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   	<span class="keyword">import</span> time</span><br><span class="line">    res_sub1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>)]</span><br><span class="line">    res_sub2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1200000</span>, <span class="number">3000000</span>)]</span><br><span class="line">    res = []</span><br><span class="line">    res.append(res_sub1)</span><br><span class="line">    res.append(res_sub2)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># multi_read_multi_write            百万级别：2.5175881385803223</span></span><br><span class="line">    <span class="comment"># multi_read_multi_write(res, multi_read, write_multiread)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># single read and multi write</span></span><br><span class="line">    <span class="comment"># single_read_multi_write(res, return_value, callback_write)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># single read and single write      百万级别：14.876289367675781</span></span><br><span class="line">    single_read_single_write(res)</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"total time: &#123;&#125;"</span>.format(end - start))</span><br><span class="line">    print(<span class="string">"finished"</span>)</span><br></pre></td></tr></table></figure>
<p>在上述代码的输出中可以看出，百万级别的对比实验中，在8核处理下，多进程读写耗时2.5，单进程耗时14.8，差距还是很明显的。下面提供一个多进程加锁读取一个文件的思路(按块读取，并使用共享内存标记读取位置)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Array, Value, RLock, Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_read</span><span class="params">(arr, pid, file_path, FILESIZE, BLOCKSIZE)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对一个文件按照 BLOCKSIZE 字节数大小来读取文件， 通过共享内存multiprocessing.Array来标记读取位置，告诉其他进程该从哪个位置开始读取</span></span><br><span class="line"><span class="string">    :param arr: 共享内存 multiprocessing.Array </span></span><br><span class="line"><span class="string">    :param pid: 进程编号</span></span><br><span class="line"><span class="string">    :param file_path: 文件位置</span></span><br><span class="line"><span class="string">    :param FILESIZE: 文件大小</span></span><br><span class="line"><span class="string">    :param BLOCKSIZE: 块大小（该块包含的字节数）</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"*FILESIZE* "</span>, FILESIZE)</span><br><span class="line">    <span class="keyword">with</span> arr.get_lock():</span><br><span class="line">        <span class="comment"># 通过加锁来修改共享内存，此时对arr的修改是原子操作</span></span><br><span class="line">        start_position = max(arr)</span><br><span class="line">        end_position = (start_position + BLOCKSIZE) <span class="keyword">if</span> (start_position + BLOCKSIZE) &lt; FILESIZE <span class="keyword">else</span> FILESIZE</span><br><span class="line">        arr[pid] = end_position     <span class="comment"># 修改共享内存，标记读取位置</span></span><br><span class="line"></span><br><span class="line">    fstream = open(file_path, <span class="string">'r'</span>)</span><br><span class="line">    fstream.seek(start_position)</span><br><span class="line"></span><br><span class="line">    cur_pos = fstream.tell()</span><br><span class="line">    <span class="comment"># 按照块的大小读取文件</span></span><br><span class="line">    <span class="keyword">while</span> cur_pos &lt; end_position:</span><br><span class="line">        line = fstream.readline()</span><br><span class="line">        cur_pos = fstream.tell()</span><br><span class="line">    <span class="comment"># 关闭文件流</span></span><br><span class="line">    fstream.close()</span><br><span class="line">    print(<span class="string">"&#123;:d&#125; starts from &#123;:d&#125;, ends to &#123;:d&#125;"</span>.format(pid, start_position, end_position))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_filesize</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取文件大小 -- 文件字节数</span></span><br><span class="line"><span class="string">    :param file_path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    fstream = open(file_path, <span class="string">'r'</span>)</span><br><span class="line">    fstream.seek(<span class="number">0</span>, os.SEEK_END)</span><br><span class="line">    FILESIZE = fstream.tell()</span><br><span class="line">    fstream.close()</span><br><span class="line">    <span class="keyword">return</span> FILESIZE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    file_path = <span class="string">r'C:\DevelopWorkspace\test\multi_read_multi_write.txt'</span></span><br><span class="line"></span><br><span class="line">    WORKERS = multiprocessing.cpu_count()</span><br><span class="line">    FILESIZE = get_filesize(file_path)</span><br><span class="line">    BLOCKSIZE = math.ceil(FILESIZE / WORKERS)</span><br><span class="line">    </span><br><span class="line">    rlock = RLock()</span><br><span class="line">    arr = Array(<span class="string">'l'</span>, WORKERS, lock=rlock)</span><br><span class="line">	print(<span class="string">"FILE SIZE: &#123;&#125;字节"</span>.format(FILESIZE))</span><br><span class="line">    process = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(WORKERS):</span><br><span class="line">        p = Process(target=multi_read, args=(arr, i, file_path, FILESIZE, BLOCKSIZE))</span><br><span class="line">        process.append(p)</span><br><span class="line">    print(<span class="string">"***MULTIPLE***"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process:</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process:</span><br><span class="line">        p.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'total time: &#123;&#125;'</span>.format(end - start))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"***SINGLE**"</span>)</span><br><span class="line">    s = time.time()</span><br><span class="line">    single_read(file_path, FILESIZE)</span><br><span class="line">    e = time.time()</span><br><span class="line">    print(<span class="string">"total time: &#123;&#125;"</span>.format(e-s))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_read</span><span class="params">(file_path, FILESIZE)</span>:</span></span><br><span class="line">    fstream = open(file_path, <span class="string">'r'</span>)</span><br><span class="line">    fstream.seek(<span class="number">0</span>)</span><br><span class="line">    cur_pos = fstream.tell()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> cur_pos &lt; FILESIZE:</span><br><span class="line">        line = fstream.readline().strip()</span><br><span class="line">        cur_pos = fstream.tell()</span><br><span class="line">    fstream.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">FILE SIZE : <span class="number">24088890</span>字节</span><br><span class="line">***MULTIPLE***</span><br><span class="line"><span class="number">3</span> starts <span class="keyword">from</span> <span class="number">12044448</span>, ends to <span class="number">15055560</span></span><br><span class="line"><span class="number">7</span> starts <span class="keyword">from</span> <span class="number">18066672</span>, ends to <span class="number">21077784</span></span><br><span class="line"><span class="number">6</span> starts <span class="keyword">from</span> <span class="number">9033336</span>, ends to <span class="number">12044448</span></span><br><span class="line"><span class="number">5</span> starts <span class="keyword">from</span> <span class="number">21077784</span>, ends to <span class="number">24088890</span></span><br><span class="line"><span class="number">4</span> starts <span class="keyword">from</span> <span class="number">15055560</span>, ends to <span class="number">18066672</span></span><br><span class="line"><span class="number">1</span> starts <span class="keyword">from</span> <span class="number">6022224</span>, ends to <span class="number">9033336</span></span><br><span class="line"><span class="number">0</span> starts <span class="keyword">from</span> <span class="number">3011112</span>, ends to <span class="number">6022224</span></span><br><span class="line"><span class="number">2</span> starts <span class="keyword">from</span> <span class="number">0</span>, ends to <span class="number">3011112</span></span><br><span class="line">total time: <span class="number">20.560996770858765</span></span><br><span class="line">***SINGLE**</span><br><span class="line">total time: <span class="number">72.99805307388306</span></span><br></pre></td></tr></table></figure>
<p>经上也可以看出多进程读取文件的速度相对于单进程而言也是占优的。</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a><em>tips</em></h2><p>使用进程池，当进程运行完后，不加<code>pool.close()</code>，直接加<code>pool.join()</code>是会报错的，因为进程池里面的进程用完之后不会结束，而是被还到进程池了，因此这里的<code>join</code><strong>检测的是没有任务再进入进程池</strong>了，而<strong>不是检测子进程</strong>的结束。所以要保证没有任务进入进程池，进程池就不会接收到任务，所以<code>pool.close()</code>的作用就是结束进程池接收任务，就是我的任务执行完毕，且没有新的任务进来，这时就被<code>join</code>检测到了。</p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a><strong><em>Appendix</em></strong></h2><p>对于共享<strong>整数</strong>或者<strong>单个字符</strong>，初始化比较简单，参照下表<strong>(Table 1)</strong>映射关系：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Type Code</th>
<th style="text-align:center">Python Type</th>
<th style="text-align:center">C Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">‘c’</td>
<td style="text-align:center">character</td>
<td style="text-align:center">char</td>
</tr>
<tr>
<td style="text-align:center">‘b’</td>
<td style="text-align:center">int</td>
<td style="text-align:center">signed char</td>
</tr>
<tr>
<td style="text-align:center">‘B’</td>
<td style="text-align:center">int</td>
<td style="text-align:center">unsigned char</td>
</tr>
<tr>
<td style="text-align:center">‘u’</td>
<td style="text-align:center">unicode character</td>
<td style="text-align:center">Py_UNICODE</td>
</tr>
<tr>
<td style="text-align:center">‘h’</td>
<td style="text-align:center">int</td>
<td style="text-align:center">signed short</td>
</tr>
<tr>
<td style="text-align:center">‘H’</td>
<td style="text-align:center">int</td>
<td style="text-align:center">unsigned short</td>
</tr>
<tr>
<td style="text-align:center">‘i’</td>
<td style="text-align:center">int</td>
<td style="text-align:center">signed int</td>
</tr>
<tr>
<td style="text-align:center">‘I’</td>
<td style="text-align:center">int</td>
<td style="text-align:center">unsigned int</td>
</tr>
<tr>
<td style="text-align:center">‘l’</td>
<td style="text-align:center">int</td>
<td style="text-align:center">signed long</td>
</tr>
<tr>
<td style="text-align:center">‘L’</td>
<td style="text-align:center">int</td>
<td style="text-align:center">unsigned long</td>
</tr>
<tr>
<td style="text-align:center">‘f’</td>
<td style="text-align:center">float</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">‘d’</td>
<td style="text-align:center">float</td>
<td style="text-align:center">double</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>比如共享整数1， 可以使用<code>Value(&#39;h&#39;, 1)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Value</span><br><span class="line">&gt; </span><br><span class="line">&gt; v = Value(<span class="string">'h'</span>, <span class="number">1</span>)</span><br><span class="line">&gt; print(v.value)        <span class="comment"># 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果共享对象是一个<strong>字符串</strong>，则需要使用原始的<strong>ctype</strong>类型，对应关系如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ctypes类型</th>
<th>Python类型</th>
<th>C类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>c_bool</td>
<td>bool(1)</td>
<td>_Bool</td>
</tr>
<tr>
<td>c_char</td>
<td>单字符字节对象</td>
<td>char</td>
</tr>
<tr>
<td>c_wchar</td>
<td>单字符字符串</td>
<td>wchar_t</td>
</tr>
<tr>
<td>c_byte</td>
<td>整型</td>
<td>char</td>
</tr>
<tr>
<td>c_ubyte</td>
<td>整型</td>
<td>unsigned char</td>
</tr>
<tr>
<td>c_short</td>
<td>整型</td>
<td>short</td>
</tr>
<tr>
<td>c_ushort</td>
<td>整型</td>
<td>unsigned short</td>
</tr>
<tr>
<td>c_int</td>
<td>整型</td>
<td>int</td>
</tr>
<tr>
<td>c_uint</td>
<td>整型</td>
<td>unsigned int</td>
</tr>
<tr>
<td>c_long</td>
<td>整型</td>
<td>long</td>
</tr>
<tr>
<td>c_ulong</td>
<td>整型</td>
<td>unsigned long</td>
</tr>
<tr>
<td>c_longlong</td>
<td>整型</td>
<td>__int64或 long long</td>
</tr>
<tr>
<td>c_ulonglong</td>
<td>整型</td>
<td>unsigned __int 64 或 unsigned long long</td>
</tr>
<tr>
<td>c_size_t</td>
<td>整型</td>
<td>size_t</td>
</tr>
<tr>
<td>c_ssize_t</td>
<td>整型</td>
<td>ssize_t 或 Py_ssize_t</td>
</tr>
<tr>
<td>c_float</td>
<td>浮点数</td>
<td>float</td>
</tr>
<tr>
<td>c_double</td>
<td>浮点数</td>
<td>double</td>
</tr>
<tr>
<td>c_longdouble</td>
<td>浮点数</td>
<td>long double</td>
</tr>
<tr>
<td>c_char_p</td>
<td>string 或<code>None</code></td>
<td>char * (NUL terminated)</td>
</tr>
<tr>
<td>c_wchar_p</td>
<td>unicode 或<code>None</code></td>
<td>wchar_t * (NUL terminated)</td>
</tr>
<tr>
<td>c_void_p</td>
<td>int 或 <code>None</code></td>
<td>void *</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 上面的Value('h', 1)可以做如下改写</span></span><br><span class="line">&gt; v = Value(c_short, <span class="number">1</span>)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 共享字符串</span></span><br><span class="line">&gt; v = Value(c_char_p, <span class="string">'hello'</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
            <a href="/tags/多进程/" rel="tag"># 多进程</a>
          
            <a href="/tags/multiprocessing/" rel="tag"># multiprocessing</a>
          
            <a href="/tags/Pool/" rel="tag"># Pool</a>
          
            <a href="/tags/Process/" rel="tag"># Process</a>
          
            <a href="/tags/进程通信/" rel="tag"># 进程通信</a>
          
            <a href="/tags/进程同步/" rel="tag"># 进程同步</a>
          
            <a href="/tags/多进程读写/" rel="tag"># 多进程读写</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/28/TF-IDF学习/" rel="next" title="TF-IDF学习">
                <i class="fa fa-chevron-left"></i> TF-IDF学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">seine7ee</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Python-基于进程的并行"><span class="nav-number">1.</span> <span class="nav-text">[Python]基于进程的并行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-subprocess-生成多余进程"><span class="nav-number">1.1.</span> <span class="nav-text">1 subprocess - 生成多余进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Multiprocessing-基于进程的并行"><span class="nav-number">1.2.</span> <span class="nav-text">2  Multiprocessing - 基于进程的并行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-上下文和启动方法"><span class="nav-number">1.2.1.</span> <span class="nav-text">I. 上下文和启动方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#II-进程间通信"><span class="nav-number">1.2.2.</span> <span class="nav-text">II. 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Queue用来在多个进程间进行通信"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1. Queue用来在多个进程间进行通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Pipe常用来在两个进程间通信"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2. Pipe常用来在两个进程间通信</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#III-进程之间的同步"><span class="nav-number">1.2.3.</span> <span class="nav-text">III. 进程之间的同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-共享内存"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">1. 共享内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-服务器进程"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2. 服务器进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-启动大量子进程"><span class="nav-number">1.3.</span> <span class="nav-text">3 启动大量子进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Pool和Process的区别"><span class="nav-number">1.4.</span> <span class="nav-text">4 Pool和Process的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-多进程读写文件-VS-单进程读写文件"><span class="nav-number">1.5.</span> <span class="nav-text">5 多进程读写文件 VS 单进程读写文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tips"><span class="nav-number">1.6.</span> <span class="nav-text">tips</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Appendix"><span class="nav-number">1.7.</span> <span class="nav-text">Appendix</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">seine7ee</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
