<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Python]基于进程的并行</title>
      <link href="/2020/04/22/Python-%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/"/>
      <url>/2020/04/22/Python-%E5%9F%BA%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-基于进程的并行"><a href="#Python-基于进程的并行" class="headerlink" title="[Python]基于进程的并行"></a>[Python]基于进程的并行</h1><h2 id="1-subprocess-生成多余进程"><a href="#1-subprocess-生成多余进程" class="headerlink" title="1 subprocess - 生成多余进程"></a>1 subprocess - 生成多余进程</h2><blockquote><p>subprocess目的是开始与其他进程交互，即用来生成子进程，并可以通过管道连接它们的输入/输出/错误，以及获得它们的返回值。</p></blockquote><p>subprocess.run()函数是在python 3.5以后被添加的，具体参数列表参见python文档，下面只解释几个常用的参数描述。</p><p><code>subprocess.run</code>(<em>args, capture_out=False, shell=False, timeout=None, check=False</em>)</p><ul><li>作用： 调用子进程，并返回进程状态码，如果一个进程被执行并结束，则返回0.</li></ul><blockquote><p>params:</p><ul><li><strong>args</strong>：指令 ，如果<strong>shell=False</strong>，则使用python解析器解析(等同于<code>subprocess.call(args)</code>)，args为<strong>命令参数列表</strong>，如果<strong>shell=True</strong>，则使用shell自己解析，则args为<strong>命令字符串</strong>；</li><li>capture_out：如果capture_out设为true，stdout和stderr将会被捕获；</li><li>timeout：见文档；</li><li><strong>check</strong>：如果check设为true，并且进程以非零状态码退出，一个CalledProcessError异常将会被抛出。 </li></ul></blockquote><h2 id="2-Multiprocessing-基于进程的并行"><a href="#2-Multiprocessing-基于进程的并行" class="headerlink" title="2  Multiprocessing - 基于进程的并行"></a>2  Multiprocessing - 基于进程的并行</h2><p>在Unix/Linux系统中提供了一个fork()函数，它比较特殊，普通函数调用一次，返回一次，而fork()函数调用一次，返回两次，因为操作系统会自动地把当前系统复制一份（也就是子进程），然后在父进程和子进程中分别返回. 其中，父进程返回子进程号，而子进程永远返回0.</p><h3 id="I-上下文和启动方法"><a href="#I-上下文和启动方法" class="headerlink" title="I. 上下文和启动方法"></a>I. 上下文和启动方法</h3><p>根据不同的平台，multiprocessing支持<strong>三种启动进程</strong>的方法. 这些启动方法有：</p><ol><li><p>spawn</p><p>父进程启动一个新的Python解释器进程，子进程只会继承那些运行进程对象的run()方法所需的资源，相对于使用fork或forserver，使用这个方法启动进程相当慢。可在Unix和Windows上使用，是在windows上的默认设置。</p></li><li><p>fork</p><p>父进程使用os.fork()来产生Python解释器分叉，只存在于Unix（Unix中的默认值）。</p></li><li><p>forkserver</p><p>程序启动并选择<em> forkserver </em> 启动方法时，将启动服务器进程。可在Unix平台上使用。</p></li></ol><p>启动方法：</p><p>可以使用<code>multiprocessing.set_start_methond(&#39;spawn&#39;)</code>或<code>multiprocessing.get_context(&#39;spawn&#39;)</code>启动。</p><blockquote><ol><li>在程序中set_start_method()不应该被多次调用；</li><li>或者，可以使用get_context()来获取上下文对象（获取一个按指定启动方法启动的multiprocessing对象）。<strong>上下文对象与多处理模块具有相同的API，并允许在统一程序中使用多个启动方法</strong>。</li></ol></blockquote><h3 id="II-进程间通信"><a href="#II-进程间通信" class="headerlink" title="II. 进程间通信"></a>II. 进程间通信</h3><p>进程间可以使用Queue或者Pipe来进行通信。</p><h4 id="1-Queue用来在多个进程间进行通信"><a href="#1-Queue用来在多个进程间进行通信" class="headerlink" title="1. Queue用来在多个进程间进行通信"></a>1. Queue用来在多个进程间进行通信</h4><p>Queue用来在多个进程间进行通信，Queue主要使用两个方法，get()和put().</p><blockquote><p><code>put(obj [, block=True [, timeout=None]])</code>：</p><ul><li>将obj放入到队列中；</li><li>如果可选参数block=True，(1)并且timeout是None，将会阻塞当前进程，直到有空的缓冲槽；(2)如果timeout是正数，将会在最多阻塞了timeout秒后，如果还是没有可用的缓冲槽时将抛出queue.Full异常。</li><li>如果可选参数block=False(此时timeout参数会被忽略掉)，仅当有可用缓冲槽时才放入队列中，否则抛出queue.Full异常。</li></ul><p>get([block [, timeout]]):</p><ul><li>从队列中取出并返回对象；</li><li>block和timeout的作用与put类似，详见python文档。</li></ul></blockquote><p>下面是一个代码实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_process</span><span class="params">(q, tokens)</span>:</span></span><br><span class="line">    <span class="comment"># 需要执行的子进程</span></span><br><span class="line">    print(<span class="string">"Write Process`s writing, process id is &#123;:d&#125;."</span>.format(os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        q.put(token)</span><br><span class="line">        print(<span class="string">'put &#123;:s&#125; to the queue.'</span>.format(token))</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_process</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">"Read Process`s reading, process id is &#123;:d&#125;."</span>.format(os.getpid()))</span><br><span class="line">    <span class="comment"># while not q.empty():</span></span><br><span class="line">    <span class="comment">#     token = q.get()</span></span><br><span class="line">    <span class="comment">#     print("get &#123;:s&#125; from the queue.".format(token))</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        token = q.get()</span><br><span class="line">        print(<span class="string">"get &#123;:s&#125; from the queue."</span>.format(token))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    q = multiprocessing.Queue()</span><br><span class="line">    <span class="comment"># 实例化子进程</span></span><br><span class="line">    pw1 = Process(target=write_process, args=(q, [<span class="string">'t1'</span>, <span class="string">'t2'</span>, <span class="string">'t3'</span>]))</span><br><span class="line">    pw2 = Process(target=write_process, args=(q, [<span class="string">'t4'</span>, <span class="string">'t5'</span>]))</span><br><span class="line">    pr = Process(target=read_process, args=(q, ))</span><br><span class="line">    <span class="comment"># 开始执行子进程</span></span><br><span class="line">    pw1.start()</span><br><span class="line">    pw2.start()</span><br><span class="line">    pr.start()</span><br><span class="line">    pw1.join()</span><br><span class="line">    pw2.join()</span><br><span class="line">    <span class="comment"># pr.join() 如果read_process使用 not q.empty()作为判断条件，由于多进程的异步性，会有元素无法从队列中取出</span></span><br><span class="line">    <span class="comment"># read_process里是一个死循环，只能强制终止</span></span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Write Process`s writing, process id <span class="keyword">is</span> <span class="number">20408.</span>Read Process`s reading, process id <span class="keyword">is</span> <span class="number">23268.</span></span><br><span class="line"></span><br><span class="line">Write Process`s writing, process id <span class="keyword">is</span> <span class="number">19232.</span></span><br><span class="line">put t1 to the queue.put t4 to the queue.</span><br><span class="line"></span><br><span class="line">get t1 <span class="keyword">from</span> the queue.</span><br><span class="line">get t4 <span class="keyword">from</span> the queue.</span><br><span class="line">put t5 to the queue.get t5 <span class="keyword">from</span> the queue.</span><br><span class="line"></span><br><span class="line">put t2 to the queue.</span><br><span class="line">get t2 <span class="keyword">from</span> the queue.</span><br><span class="line">put t3 to the queue.</span><br><span class="line">get t3 <span class="keyword">from</span> the queue.</span><br></pre></td></tr></table></figure><p><strong>扩展</strong></p><blockquote><p>在最近的项目中碰到了multiprocessing.SimpleQueue，记录一下.</p><p><strong>class multiprocessing.SimpleQueue</strong></p><p>- 这是一个简化的Queue类的实现，很像带锁的Pipe.</p><ol><li><p>empty(）</p><p>- 如果队列为空则返回True，否则返回False.</p></li><li><p>get()</p><p>- 从队列中移除并返回一个对象.</p></li><li><p>put(item)</p><p>- 将item放入队列.</p></li></ol></blockquote><h4 id="2-Pipe常用来在两个进程间通信"><a href="#2-Pipe常用来在两个进程间通信" class="headerlink" title="2. Pipe常用来在两个进程间通信"></a>2. Pipe常用来在两个进程间通信</h4><p>Pipe常用来在两个进程间通信，两个进程分别位于管道的两端.</p><blockquote><p><code>multiprocessing.Pipe([duplex=True])</code></p><p>- 返回一对Connection对象，(conn1, conn2)分别表示管道的两端;</p><p>- 如果duplex被置为True，那么该管道是双向的，如果为False，那么该管道是单向的，即conn1只能用于接收消息，conn2只能用于发送消息.</p><p>管道是将一系列标准输入输出链接起来的进程，其中每一个进程的输出被直接作为下一个进程的输入.</p></blockquote><p>代码实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="comment"># 要执行的子进程</span></span><br><span class="line">    pipe.send(<span class="string">"This is a message."</span>)</span><br><span class="line">    pipe.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    (send_pipe, recv_pipe) = Pipe()</span><br><span class="line">    <span class="comment"># 实例化进程</span></span><br><span class="line">    p = Process(target=send, args=(send_pipe, ))</span><br><span class="line">    <span class="comment"># 执行子进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(recv_pipe.recv())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a message.</span><br></pre></td></tr></table></figure><p>管道同时进行发送信息和接收信息（双工通信）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="comment"># 要执行的子进程</span></span><br><span class="line">    pipe.send(<span class="string">"This is a message."</span>)                <span class="comment"># 管道发送信息</span></span><br><span class="line">    pipe.close()                                   <span class="comment"># 关闭管道</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sender</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(&#123;<span class="string">"name"</span>: <span class="string">"sender"</span>, <span class="string">"content"</span>: <span class="string">"Do you copy?"</span>&#125;)</span><br><span class="line">    recv = pipe.recv()</span><br><span class="line">    print(<span class="string">"sender got: "</span>, recv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    (send_pipe, recv_pipe) = Pipe()                 <span class="comment"># Pipe()返回一对管道实例</span></span><br><span class="line">    s = Process(target=sender, args=(send_pipe, ))  <span class="comment"># 实例化sender进程</span></span><br><span class="line">    s.start()</span><br><span class="line">    recv = recv_pipe.recv()                         <span class="comment"># recv_pipe是一个Pipe管道，可以接收send_pipe发送过来的消息</span></span><br><span class="line">    print(<span class="string">"recver got: "</span>, recv)                     <span class="comment"># 打印recv_pipe接收的来自send_pipe的消息</span></span><br><span class="line">    recv_pipe.send(<span class="string">"roger that."</span>)                   <span class="comment"># recv_pipe同时又能发送消息</span></span><br><span class="line">    s.join()</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">recver got:  &#123;&apos;name&apos;: &apos;sender&apos;, &apos;content&apos;: &apos;Do you copy?&apos;&#125;</span><br><span class="line">sender got:  roger that.</span><br></pre></td></tr></table></figure><h3 id="III-进程之间的同步"><a href="#III-进程之间的同步" class="headerlink" title="III. 进程之间的同步"></a>III. 进程之间的同步</h3><p>在进行并发编程时，通常最好<strong>尽量避免使用共享状态</strong>，使用多个进程时尤其如此。</p><p>但是，如果真的需要使用一些共享数据，那么<code>multiprocessing</code>提供了两种方法。</p><h4 id="1-共享内存"><a href="#1-共享内存" class="headerlink" title="1. 共享内存"></a>1. 共享内存</h4><p>可以使用<code>Value</code>或<code>Array</code>将<strong>数据存储在共享内存映射</strong>中， <code>Value</code>和<code>Array</code>在python3.7中只能供<code>multiprocessing.Process</code>使用，而不能被<code>multiprocessing.Pool</code>使用，</p><p><code>multiprocessing.Value</code>和<code>multiprocessing.Array</code>是共享<code>ctypes</code>对象</p><ol><li><p><strong>Value</strong>(typecode_or_type, <em>args, lock=True</em>)</p><p><strong>属性和方法</strong>：</p><ul><li>value： 获取值</li><li>get_lock()：获取锁对象</li><li>acquire/release：获取锁/释放锁</li></ul><p><strong>介绍</strong>：</p><p>返回一个从共享内存上创建的ctypes对象，可以通过<code>Value</code>的<code>value</code>属性访问这个对象本身。</p><p><code>typecode_or_type</code>: 指明了返回的对象类型， 对象类型如<strong>(附录)Table 1</strong>所示。</p><p>如果<code>lock</code>是<code>True</code>， 将会新建一个递归锁用于同步对于此值的访问操作，如果<code>lock</code>是<code>Lock</code>或者<code>RLock</code>对象，那么传入的锁将会用于同步对这个值的访问操作，如果<code>lock</code>是<code>False</code>，那么对这个对象的访问将没有锁保护，也就是说这个变量不是进程安全的。</p><p>对于<code>+=</code>这样的操作会引发独立的读操作和写操作，也就是说这类操作符不具有原子性。所以，如果你想让递增操作具有原子性，这样的方式并不能达到要求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">couter.value += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>假设共享对象内部关联的锁是递归锁(默认情况下)，为了让这样的操作具有原子性，那么可以为该操作加锁，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> couter.get_lock():</span><br><span class="line">    counter.value += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock, Value</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_sum</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        val.value += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    val = Value(<span class="string">'i'</span>, <span class="number">0</span>)</span><br><span class="line">    process_list = [Process(target=func_sum, args=(val, )) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> process_list:</span><br><span class="line">        process.start()</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> process_list:</span><br><span class="line">        process.join()</span><br><span class="line">    print(val.value)     <span class="comment"># val.value每次得出的结果都不一样，但不等于100</span></span><br></pre></td></tr></table></figure><p>我们通过创建一个共享对象<code>Value</code>，希望经过100次迭代后，其值能够达到100，但实际的输出并不是100，<code>Value</code>的参数中<code>lock</code>默认是True，意味着将会创建一个递归锁对象用于同步访问控制，然而，要想实现真正的同步访问控制，需要实现获取这个锁，经过修改，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_with_lock</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">with</span> val.get_lock():</span><br><span class="line">            val.value += <span class="number">1</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        也可以这样获得锁：</span></span><br><span class="line"><span class="string">        if val.acquire():</span></span><br><span class="line"><span class="string">        val.value += 1</span></span><br><span class="line"><span class="string">        val.release()</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    val = Value(<span class="string">'i'</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># process_list = [Process(target=func_sum, args=(val, )) for i in range(10)]</span></span><br><span class="line">    process_list = [Process(target=func_with_lock, args=(val,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> process_list:</span><br><span class="line">        process.start()</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> process_list:</span><br><span class="line">        process.join()</span><br><span class="line">    print(val.value)   <span class="comment"># 100</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p><strong>Array</strong>(<em>typecode_or_type, size_or_initializer, \</em>, lock=True*)</p><p>从共享内存中申请并返回一个具有ctypes类型的数组对象。</p><p><code>typecode_or_type</code> 指明了返回的数组中的元素类型: 它可能是一个 <code>ctypes</code> 类型或者 <code>array</code> 模块中每个类型对应的单字符长度的字符串。 </p><p>如果 <code>size_or_initializer</code> 是一个整数，那就会当做数组的长度，并且整个数组会初始化为0。否则，如果 <code>size_or_initializer</code> 会被当成一个序列用于初始化数组中的每一个元素，并且会根据元素个数自动判断数组的长度。</p><p>也就是说，<code>size_or_initializer</code> 只能是两种情况：</p><ol><li>是一个整数；</li><li>是一个序列，如<code>list</code>，<code>tuple</code>， <code>range</code>（python的序列类型就这三种）。</li></ol></li></ol><h4 id="2-服务器进程"><a href="#2-服务器进程" class="headerlink" title="2. 服务器进程"></a>2. 服务器进程</h4><p>由 <code>Manager()</code> 返回的管理器对象控制一个服务器进程，该进程保存Python对象并允许其他进程使用代理操作它们。<strong><code>multiprocessing.Pool</code>只能使用<code>Manager()</code>来实现进程同步。</strong></p><p><code>Manager()</code> 返回的管理器支持类型： <code>list 、 dict 、 Namespace 、 Lock 、 RLock 、 Semaphore 、 BoundedSemaphore 、 Condition 、 Event 、 Barrier 、 Queue 、 Value 和 Array</code> 。</p><p>使用示例见<strong>1.5.5 多进程读写文件</strong></p><h2 id="3-启动大量子进程"><a href="#3-启动大量子进程" class="headerlink" title="3 启动大量子进程"></a>3 启动大量子进程</h2><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程。</p><blockquote><p>class multiprocessing.Pool([process [, initializer [, initargs [, maxtasksperchild [ , context]]]]])</p><ul><li><p>一个进程池对象，它控制可以提交作业的工作进程池。支持带有超时和回调的异步结果，以及一个并行的map实现；</p></li><li><p>params:</p><p>- process: 使用的工作进程数，如果process=None，则使用os.cpu_count()返回的值</p></li><li><p>funcs：</p><ol><li><p><code>apply</code>(<em>func</em>[, <em>args</em>[, <em>kwds</em>]])</p><p>使用args参数以及kwds命名参数调用func，它会返回结果前阻塞。这种情况下，apply_async()更适合并行化工作，另外func只会在一个进程池中的一个工作进程中执行。</p></li><li><p><code>apply_async</code>(<em>func</em>[, <em>args</em>[, <em>kwds</em>[, <em>callback</em>[, <em>error_callback</em>]]]])</p><p><code>apply()</code>方法的变种，返回一个结果对象。</p></li><li><p><code>join()</code></p><p>等待工作进程结束，<strong>调用<code>join()</code>前必须先调用<code>close()</code>或者<code>terminate()</code></strong></p></li></ol></li></ul></blockquote><p>代码实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line">    p.close()                                         <span class="comment"># close() - 阻止后续任务提交到进程池，当所有任务执行完成后，工作进程会退出 </span></span><br><span class="line">    p.join()                                          <span class="comment"># join() - 等待工作进程结束，调用join()前必须先调用close()或者terminate()</span></span><br><span class="line">    print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parent process <span class="number">26060.</span></span><br><span class="line">Waiting <span class="keyword">for</span> all subprocesses done...</span><br><span class="line">Run task <span class="number">0</span> (<span class="number">21004</span>)...</span><br><span class="line">Run task <span class="number">1</span> (<span class="number">24740</span>)...</span><br><span class="line">Run task <span class="number">2</span> (<span class="number">13948</span>)...</span><br><span class="line">Run task <span class="number">3</span> (<span class="number">25100</span>)...</span><br><span class="line">Task <span class="number">2</span> runs <span class="number">0.54</span> seconds.</span><br><span class="line">Run task <span class="number">4</span> (<span class="number">13948</span>)...</span><br><span class="line">Task <span class="number">0</span> runs <span class="number">0.93</span> seconds.</span><br><span class="line">Task <span class="number">1</span> runs <span class="number">0.98</span> seconds.</span><br><span class="line">Task <span class="number">3</span> runs <span class="number">1.79</span> seconds.</span><br><span class="line">Task <span class="number">4</span> runs <span class="number">1.57</span> seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure><h2 id="4-Pool和Process的区别"><a href="#4-Pool和Process的区别" class="headerlink" title="4 Pool和Process的区别"></a>4 Pool和Process的区别</h2><ol><li><code>multiprocessing.Pool</code>可以批量启动子进程，而<code>multiprocessing.Process</code>一次只能启动一个进程，当然<code>multiprocessing.Process</code>可以使用列表生成式来创建一个子进程列表；</li><li><code>Process</code>可以直接使用<code>Queue</code>来进行进程间的通信，而<code>Pool</code>如果想实现进程间的通信，只能使用共享内存来实现，即使用<code>Manager().Queue</code>来实现进程间的通信；</li><li><code>Process</code>可以直接使用共享内存<code>Array</code>和<code>Value</code>来实现进程同步，而<code>Pool</code>不能直接使用<code>Array</code>和<code>Value</code>，<code>Pool</code>要想实现进程同步、进程通信，可以使用<code>multiprocessing.Manager</code>。</li></ol><h2 id="5-多进程读写文件-VS-单进程读写文件"><a href="#5-多进程读写文件-VS-单进程读写文件" class="headerlink" title="5 多进程读写文件 VS 单进程读写文件"></a>5 多进程读写文件 VS 单进程读写文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Array, RLock, Value, Manager</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_read</span><span class="params">(multi_val, arr, arr_len, interval, rlock)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    多进程分块读数组内容，并返回一个interval长度的字符串</span></span><br><span class="line"><span class="string">    :param multi_arr:</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :param arr_len:</span></span><br><span class="line"><span class="string">    :param pid:</span></span><br><span class="line"><span class="string">    :param interval:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">with</span> rlock:</span><br><span class="line">        start_idx = multi_val.value</span><br><span class="line">        end_idx = (start_idx + interval) <span class="keyword">if</span> (start_idx + interval) &lt; arr_len <span class="keyword">else</span> arr_len</span><br><span class="line">        multi_val.value = end_idx</span><br><span class="line"></span><br><span class="line">    cur_idx = start_idx</span><br><span class="line">    string_value = <span class="string">''</span></span><br><span class="line">    <span class="keyword">while</span> cur_idx &lt; end_idx:</span><br><span class="line">        string_value += (str(arr[cur_idx]) + <span class="string">'\n'</span>)</span><br><span class="line">        cur_idx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> string_value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_multiread</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    向文件中写字符串</span></span><br><span class="line"><span class="string">    该函数是一个回调函数，其接收的参数为 multi_read 返回的值</span></span><br><span class="line"><span class="string">    :param s:</span></span><br><span class="line"><span class="string">    :param file_path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    file_path = <span class="string">r"C:\DevelopWorkspace\test\multi_read_multi_write_10_billion.txt"</span></span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'a+'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_read_multi_write</span><span class="params">(res, multi_read, write_multiread)</span>:</span></span><br><span class="line">    workers = multiprocessing.cpu_count()</span><br><span class="line">    p = Pool(workers)</span><br><span class="line">    manager = Manager()</span><br><span class="line">    rlock = manager.RLock()</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    logger.info(<span class="string">'start time: &#123;&#125;'</span>.format(start))</span><br><span class="line">    <span class="keyword">for</span> sub_list <span class="keyword">in</span> res:</span><br><span class="line">        length = len(sub_list)</span><br><span class="line">        interval = math.ceil(length / workers)</span><br><span class="line">        multi_val = manager.Value(<span class="string">'l'</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 异步执行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(workers):</span><br><span class="line">            p.apply_async(multi_read, args=(multi_val, sub_list, length, interval, rlock), callback=write_multiread)</span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment"># 单进程读单进程写</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_read_single_write</span><span class="params">(res)</span>:</span></span><br><span class="line">    file_path = <span class="string">r"C:\DevelopWorkspace\test\single_read_single_write_10_billion.txt"</span></span><br><span class="line">    <span class="keyword">for</span> sub <span class="keyword">in</span> res:</span><br><span class="line">        string_value = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> sub:</span><br><span class="line">            string_value += str(ele) + <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">with</span> open(file_path, <span class="string">'a+'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            file.write(string_value)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   <span class="keyword">import</span> time</span><br><span class="line">    res_sub1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>)]</span><br><span class="line">    res_sub2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1200000</span>, <span class="number">3000000</span>)]</span><br><span class="line">    res = []</span><br><span class="line">    res.append(res_sub1)</span><br><span class="line">    res.append(res_sub2)</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># multi_read_multi_write            百万级别：2.5175881385803223</span></span><br><span class="line">    <span class="comment"># multi_read_multi_write(res, multi_read, write_multiread)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># single read and multi write</span></span><br><span class="line">    <span class="comment"># single_read_multi_write(res, return_value, callback_write)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># single read and single write      百万级别：14.876289367675781</span></span><br><span class="line">    single_read_single_write(res)</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">"total time: &#123;&#125;"</span>.format(end - start))</span><br><span class="line">    print(<span class="string">"finished"</span>)</span><br></pre></td></tr></table></figure><p>在上述代码的输出中可以看出，百万级别的对比实验中，在8核处理下，多进程读写耗时2.5，单进程耗时14.8，差距还是很明显的。下面提供一个多进程加锁读取一个文件的思路(按块读取，并使用共享内存标记读取位置)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Array, Value, RLock, Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_read</span><span class="params">(arr, pid, file_path, FILESIZE, BLOCKSIZE)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对一个文件按照 BLOCKSIZE 字节数大小来读取文件， 通过共享内存multiprocessing.Array来标记读取位置，告诉其他进程该从哪个位置开始读取</span></span><br><span class="line"><span class="string">    :param arr: 共享内存 multiprocessing.Array </span></span><br><span class="line"><span class="string">    :param pid: 进程编号</span></span><br><span class="line"><span class="string">    :param file_path: 文件位置</span></span><br><span class="line"><span class="string">    :param FILESIZE: 文件大小</span></span><br><span class="line"><span class="string">    :param BLOCKSIZE: 块大小（该块包含的字节数）</span></span><br><span class="line"><span class="string">    :return: </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"*FILESIZE* "</span>, FILESIZE)</span><br><span class="line">    <span class="keyword">with</span> arr.get_lock():</span><br><span class="line">        <span class="comment"># 通过加锁来修改共享内存，此时对arr的修改是原子操作</span></span><br><span class="line">        start_position = max(arr)</span><br><span class="line">        end_position = (start_position + BLOCKSIZE) <span class="keyword">if</span> (start_position + BLOCKSIZE) &lt; FILESIZE <span class="keyword">else</span> FILESIZE</span><br><span class="line">        arr[pid] = end_position     <span class="comment"># 修改共享内存，标记读取位置</span></span><br><span class="line"></span><br><span class="line">    fstream = open(file_path, <span class="string">'r'</span>)</span><br><span class="line">    fstream.seek(start_position)</span><br><span class="line"></span><br><span class="line">    cur_pos = fstream.tell()</span><br><span class="line">    <span class="comment"># 按照块的大小读取文件</span></span><br><span class="line">    <span class="keyword">while</span> cur_pos &lt; end_position:</span><br><span class="line">        line = fstream.readline()</span><br><span class="line">        cur_pos = fstream.tell()</span><br><span class="line">    <span class="comment"># 关闭文件流</span></span><br><span class="line">    fstream.close()</span><br><span class="line">    print(<span class="string">"&#123;:d&#125; starts from &#123;:d&#125;, ends to &#123;:d&#125;"</span>.format(pid, start_position, end_position))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_filesize</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取文件大小 -- 文件字节数</span></span><br><span class="line"><span class="string">    :param file_path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    fstream = open(file_path, <span class="string">'r'</span>)</span><br><span class="line">    fstream.seek(<span class="number">0</span>, os.SEEK_END)</span><br><span class="line">    FILESIZE = fstream.tell()</span><br><span class="line">    fstream.close()</span><br><span class="line">    <span class="keyword">return</span> FILESIZE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    file_path = <span class="string">r'C:\DevelopWorkspace\test\multi_read_multi_write.txt'</span></span><br><span class="line"></span><br><span class="line">    WORKERS = multiprocessing.cpu_count()</span><br><span class="line">    FILESIZE = get_filesize(file_path)</span><br><span class="line">    BLOCKSIZE = math.ceil(FILESIZE / WORKERS)</span><br><span class="line">    </span><br><span class="line">    rlock = RLock()</span><br><span class="line">    arr = Array(<span class="string">'l'</span>, WORKERS, lock=rlock)</span><br><span class="line">print(<span class="string">"FILE SIZE: &#123;&#125;字节"</span>.format(FILESIZE))</span><br><span class="line">    process = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(WORKERS):</span><br><span class="line">        p = Process(target=multi_read, args=(arr, i, file_path, FILESIZE, BLOCKSIZE))</span><br><span class="line">        process.append(p)</span><br><span class="line">    print(<span class="string">"***MULTIPLE***"</span>)</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process:</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process:</span><br><span class="line">        p.join()</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">'total time: &#123;&#125;'</span>.format(end - start))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"***SINGLE**"</span>)</span><br><span class="line">    s = time.time()</span><br><span class="line">    single_read(file_path, FILESIZE)</span><br><span class="line">    e = time.time()</span><br><span class="line">    print(<span class="string">"total time: &#123;&#125;"</span>.format(e-s))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_read</span><span class="params">(file_path, FILESIZE)</span>:</span></span><br><span class="line">    fstream = open(file_path, <span class="string">'r'</span>)</span><br><span class="line">    fstream.seek(<span class="number">0</span>)</span><br><span class="line">    cur_pos = fstream.tell()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> cur_pos &lt; FILESIZE:</span><br><span class="line">        line = fstream.readline().strip()</span><br><span class="line">        cur_pos = fstream.tell()</span><br><span class="line">    fstream.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 执行结果</span></span><br><span class="line">FILE SIZE : <span class="number">24088890</span>字节</span><br><span class="line">***MULTIPLE***</span><br><span class="line"><span class="number">3</span> starts <span class="keyword">from</span> <span class="number">12044448</span>, ends to <span class="number">15055560</span></span><br><span class="line"><span class="number">7</span> starts <span class="keyword">from</span> <span class="number">18066672</span>, ends to <span class="number">21077784</span></span><br><span class="line"><span class="number">6</span> starts <span class="keyword">from</span> <span class="number">9033336</span>, ends to <span class="number">12044448</span></span><br><span class="line"><span class="number">5</span> starts <span class="keyword">from</span> <span class="number">21077784</span>, ends to <span class="number">24088890</span></span><br><span class="line"><span class="number">4</span> starts <span class="keyword">from</span> <span class="number">15055560</span>, ends to <span class="number">18066672</span></span><br><span class="line"><span class="number">1</span> starts <span class="keyword">from</span> <span class="number">6022224</span>, ends to <span class="number">9033336</span></span><br><span class="line"><span class="number">0</span> starts <span class="keyword">from</span> <span class="number">3011112</span>, ends to <span class="number">6022224</span></span><br><span class="line"><span class="number">2</span> starts <span class="keyword">from</span> <span class="number">0</span>, ends to <span class="number">3011112</span></span><br><span class="line">total time: <span class="number">20.560996770858765</span></span><br><span class="line">***SINGLE**</span><br><span class="line">total time: <span class="number">72.99805307388306</span></span><br></pre></td></tr></table></figure><p>经上也可以看出多进程读取文件的速度相对于单进程而言也是占优的。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a><em>tips</em></h2><p>使用进程池，当进程运行完后，不加<code>pool.close()</code>，直接加<code>pool.join()</code>是会报错的，因为进程池里面的进程用完之后不会结束，而是被还到进程池了，因此这里的<code>join</code><strong>检测的是没有任务再进入进程池</strong>了，而<strong>不是检测子进程</strong>的结束。所以要保证没有任务进入进程池，进程池就不会接收到任务，所以<code>pool.close()</code>的作用就是结束进程池接收任务，就是我的任务执行完毕，且没有新的任务进来，这时就被<code>join</code>检测到了。</p><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a><strong><em>Appendix</em></strong></h2><p>对于共享<strong>整数</strong>或者<strong>单个字符</strong>，初始化比较简单，参照下表<strong>(Table 1)</strong>映射关系：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Type Code</th><th style="text-align:center">Python Type</th><th style="text-align:center">C Type</th></tr></thead><tbody><tr><td style="text-align:center">‘c’</td><td style="text-align:center">character</td><td style="text-align:center">char</td></tr><tr><td style="text-align:center">‘b’</td><td style="text-align:center">int</td><td style="text-align:center">signed char</td></tr><tr><td style="text-align:center">‘B’</td><td style="text-align:center">int</td><td style="text-align:center">unsigned char</td></tr><tr><td style="text-align:center">‘u’</td><td style="text-align:center">unicode character</td><td style="text-align:center">Py_UNICODE</td></tr><tr><td style="text-align:center">‘h’</td><td style="text-align:center">int</td><td style="text-align:center">signed short</td></tr><tr><td style="text-align:center">‘H’</td><td style="text-align:center">int</td><td style="text-align:center">unsigned short</td></tr><tr><td style="text-align:center">‘i’</td><td style="text-align:center">int</td><td style="text-align:center">signed int</td></tr><tr><td style="text-align:center">‘I’</td><td style="text-align:center">int</td><td style="text-align:center">unsigned int</td></tr><tr><td style="text-align:center">‘l’</td><td style="text-align:center">int</td><td style="text-align:center">signed long</td></tr><tr><td style="text-align:center">‘L’</td><td style="text-align:center">int</td><td style="text-align:center">unsigned long</td></tr><tr><td style="text-align:center">‘f’</td><td style="text-align:center">float</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">‘d’</td><td style="text-align:center">float</td><td style="text-align:center">double</td></tr></tbody></table></div><blockquote><p>比如共享整数1， 可以使用<code>Value(&#39;h&#39;, 1)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Value</span><br><span class="line">&gt; </span><br><span class="line">&gt; v = Value(<span class="string">'h'</span>, <span class="number">1</span>)</span><br><span class="line">&gt; print(v.value)        <span class="comment"># 1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果共享对象是一个<strong>字符串</strong>，则需要使用原始的<strong>ctype</strong>类型，对应关系如下：</p><div class="table-container"><table><thead><tr><th>ctypes类型</th><th>Python类型</th><th>C类型</th></tr></thead><tbody><tr><td>c_bool</td><td>bool(1)</td><td>_Bool</td></tr><tr><td>c_char</td><td>单字符字节对象</td><td>char</td></tr><tr><td>c_wchar</td><td>单字符字符串</td><td>wchar_t</td></tr><tr><td>c_byte</td><td>整型</td><td>char</td></tr><tr><td>c_ubyte</td><td>整型</td><td>unsigned char</td></tr><tr><td>c_short</td><td>整型</td><td>short</td></tr><tr><td>c_ushort</td><td>整型</td><td>unsigned short</td></tr><tr><td>c_int</td><td>整型</td><td>int</td></tr><tr><td>c_uint</td><td>整型</td><td>unsigned int</td></tr><tr><td>c_long</td><td>整型</td><td>long</td></tr><tr><td>c_ulong</td><td>整型</td><td>unsigned long</td></tr><tr><td>c_longlong</td><td>整型</td><td>__int64或 long long</td></tr><tr><td>c_ulonglong</td><td>整型</td><td>unsigned __int 64 或 unsigned long long</td></tr><tr><td>c_size_t</td><td>整型</td><td>size_t</td></tr><tr><td>c_ssize_t</td><td>整型</td><td>ssize_t 或 Py_ssize_t</td></tr><tr><td>c_float</td><td>浮点数</td><td>float</td></tr><tr><td>c_double</td><td>浮点数</td><td>double</td></tr><tr><td>c_longdouble</td><td>浮点数</td><td>long double</td></tr><tr><td>c_char_p</td><td>string 或<code>None</code></td><td>char * (NUL terminated)</td></tr><tr><td>c_wchar_p</td><td>unicode 或<code>None</code></td><td>wchar_t * (NUL terminated)</td></tr><tr><td>c_void_p</td><td>int 或 <code>None</code></td><td>void *</td></tr></tbody></table></div><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 上面的Value('h', 1)可以做如下改写</span></span><br><span class="line">&gt; v = Value(c_short, <span class="number">1</span>)</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 共享字符串</span></span><br><span class="line">&gt; v = Value(c_char_p, <span class="string">'hello'</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 多进程 </tag>
            
            <tag> multiprocessing </tag>
            
            <tag> Pool </tag>
            
            <tag> Process </tag>
            
            <tag> 进程通信 </tag>
            
            <tag> 进程同步 </tag>
            
            <tag> 多进程读写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TF-IDF学习</title>
      <link href="/2020/02/28/TF-IDF%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/02/28/TF-IDF%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="TF-IDF学习"><a href="#TF-IDF学习" class="headerlink" title="TF-IDF学习"></a>TF-IDF学习</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>TF-IDF(term frequency - inverse document frequence)是一种用于信息检索和数据挖掘的常用加权技术。使用TF-IDF是因为计算机只能识别数字，对于文本总出现的单词，计算机无法对它们进行数据处理，需要将文本转换成数学上的概念，便于进一步的训练。</p><p>思想：</p><p><strong>字词的重要性与该字词在文件中出现的次数成正比，而与该字词在语料库中出现的次数成反比。</strong>也就是说，如果一个单词在<strong>某篇文章中出现的频率较高</strong>，<strong>而在其他文章中出现的频率不是很高</strong>，则认为<strong>该词语具有很好的区分能力</strong>，适合用来做分类。</p><h6 id="1-TF是指单词在一个文本中出现的频率，即某个单词的频次-文档中所有单词的频次总和："><a href="#1-TF是指单词在一个文本中出现的频率，即某个单词的频次-文档中所有单词的频次总和：" class="headerlink" title="(1) TF是指单词在一个文本中出现的频率，即某个单词的频次/文档中所有单词的频次总和："></a>(1) TF是指单词在一个文本中出现的频率，即某个单词的频次/文档中所有单词的频次总和：</h6><script type="math/tex; mode=display">TF_{i} = {n_{i}\over \sum_{j=0}^kn_j}</script><h6 id="2-IDF是指逆文档频率，即某个词语的IDF可以由语料库中的文档总数除以包含该单词的文档数，然后取对数得到，它的计算方式如下（加一是为了避免分母为0的情况）："><a href="#2-IDF是指逆文档频率，即某个词语的IDF可以由语料库中的文档总数除以包含该单词的文档数，然后取对数得到，它的计算方式如下（加一是为了避免分母为0的情况）：" class="headerlink" title="(2) IDF是指逆文档频率，即某个词语的IDF可以由语料库中的文档总数除以包含该单词的文档数，然后取对数得到，它的计算方式如下（加一是为了避免分母为0的情况）："></a>(2) IDF是指逆文档频率，即某个词语的IDF可以由语料库中的文档总数除以包含该单词的文档数，然后取对数得到，它的计算方式如下（加一是为了避免分母为0的情况）：</h6><script type="math/tex; mode=display">IDF_i = log({文档总数 \over {包含单词i的文档数 + 1}})</script><h6 id="3-TF-IDF就是TF-IDF"><a href="#3-TF-IDF就是TF-IDF" class="headerlink" title="(3) TF-IDF就是TF * IDF"></a>(3) TF-IDF就是TF * IDF</h6><p>​    TF-IDF较为简单，没有考虑语义信息，因此不能处理一词多义和一义多词的情形。</p><h6 id="4-计算过程介绍"><a href="#4-计算过程介绍" class="headerlink" title="(4) 计算过程介绍"></a>(4) 计算过程介绍</h6><p>一个文本经过TF-IDF处理以后，就会变成文本向量，具体如下：</p><blockquote><ol><li>原始文本</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; text = <span class="string">'人来又人往，玫瑰色花香。已悄悄成为过往。'</span></span><br><span class="line">&gt; <span class="comment"># 分词文本</span></span><br><span class="line">&gt; text = [<span class="string">'人 来 又 人往 ， 玫瑰色 花香 。'</span>, <span class="string">'已 悄悄 成为 过往 。'</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ol><li>获取词袋</li></ol><p>text中有两句话，可以将每一句话都看作一个文本，我们可以获取所有文本中的单词(即获取词袋中的单词)，词袋中的单词如下(ordered)， 词袋中单词的数目为6个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="string">'人往'</span>, <span class="string">'悄悄'</span>, <span class="string">'成为'</span>, <span class="string">'玫瑰色'</span>, <span class="string">'花香'</span>, <span class="string">'过往'</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ol><li><p>构建文本向量</p><p>每一个文本的文本向量的维度是(1, 词袋长度)，那么对于text中的第一句话而言，它的分词结果如下（去除停用词后）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="string">'人 人往 玫瑰色 花香'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>&gt;</p><blockquote><p>   那么在第一句话的文本向量中的每个元素就是，词袋中每个单词出现在第一句话中的频次。</p><div class="table-container"><table><thead><tr><th>频次</th><th>1</th><th>0</th><th>0</th><th>1</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>单词</td><td>人往</td><td>悄悄</td><td>成为</td><td>玫瑰色</td><td>花香</td><td>过往</td></tr></tbody></table></div><ol><li><p>计算TF-IDF值</p><p>这样就为每个文本（每句话）得到了一个向量，以第一句话为例，向量如下：</p><p>| TF-IDF | 0.58 | 0.   | 0.   | 0.58   | 0.58 | 0.   |<br>| ——— | —— | —— | —— | ——— | —— | —— |<br>| 单词   | 人往 | 悄悄 | 成为 | 玫瑰色 | 花香 | 过往 |</p></li></ol></blockquote><h2 id="2-应用"><a href="#2-应用" class="headerlink" title="2. 应用"></a>2. 应用</h2><p>在搜索引擎，关键词提取，文本相似性和文本分类中都有使用。</p><h2 id="3-python用sklearn实现中文文本的TF-IDF计算"><a href="#3-python用sklearn实现中文文本的TF-IDF计算" class="headerlink" title="3. python用sklearn实现中文文本的TF-IDF计算"></a>3. python用sklearn实现中文文本的TF-IDF计算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用正则表达式实现文本分句</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sent_segmentor</span><span class="params">(para, chn=True)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    <span class="keyword">if</span> chn:</span><br><span class="line">        para = re.sub(<span class="string">r'([。！？\?])([^”’])'</span>, <span class="string">r'\1\n\2'</span>, para)</span><br><span class="line">        para = re.sub(<span class="string">r'(\.&#123;6&#125;)([^”’])'</span>, <span class="string">r'\1\n\2'</span>, para) <span class="comment"># 匹配出英文省略号</span></span><br><span class="line">        para = re.sub(<span class="string">r'(\…&#123;2&#125;)([^”’])'</span>, <span class="string">r'\1\n\2'</span>, para) <span class="comment"># 匹配中文省略号，并分行</span></span><br><span class="line">        para = re.sub(<span class="string">r'([。！？\?])([”’])'</span>, <span class="string">r'\1\n\2'</span>, para)</span><br><span class="line">        </span><br><span class="line">        para = para.rstrip()</span><br><span class="line">        <span class="keyword">return</span> re.split(<span class="string">r'\n'</span>, para)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        para = re.sub(<span class="string">r'([\.\!\?])([^\"\'])'</span>, <span class="string">r'\1\n\2'</span>, para)</span><br><span class="line">        para = re.sub(<span class="string">r'(\.&#123;6&#125;)([^\"\'])'</span>, <span class="string">r'\1\n\2'</span>, para)</span><br><span class="line">        para = re.sub(<span class="string">r'([\.\!\?])([\"\'])'</span>, <span class="string">r'\1\n\2'</span>, para)</span><br><span class="line">        </span><br><span class="line">        para = para.rstrip()</span><br><span class="line">        <span class="keyword">return</span> para.split(<span class="string">r'\n'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入停用词表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stopwords</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(url, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">       stopwords = file.readlines()</span><br><span class="line">    stopwords = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> stopwords]</span><br><span class="line">    <span class="keyword">return</span> stopwords</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入sklearn需要的包</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> feature_extraction</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfTransformer</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 导入pkuseg包，用于后面分词</span></span><br><span class="line">    <span class="keyword">import</span> pkuseg</span><br><span class="line">   </span><br><span class="line">    text = <span class="string">'人来又人往，玫瑰色花香。已悄悄成为过往。'</span></span><br><span class="line">    stopwords = stopwords(<span class="string">r"D:\nlp_tools\stopwords\HIT_stopwords.txt"</span>)</span><br><span class="line">    <span class="comment"># 加载分词模型</span></span><br><span class="line">    seg = pkuseg.pkuseg()</span><br><span class="line">    <span class="comment"># 构建语料库</span></span><br><span class="line">    sents = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sent_segmentor(text):</span><br><span class="line">        words = []</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> seg.cut(line):</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> stopwords:</span><br><span class="line">                words.append(word)</span><br><span class="line">       words = <span class="string">" "</span>.join(words)</span><br><span class="line">        sents.append(words.strip())</span><br><span class="line"></span><br><span class="line">    vectorizer = CountVectorizer()</span><br><span class="line">   tf_idf = TfidfTransformer()</span><br><span class="line">    matrix = vectorizer.fit_transform(sents)</span><br><span class="line">    print(<span class="string">"这是词袋："</span>)</span><br><span class="line">    print(vectorizer.get_feature_names())</span><br><span class="line">    print(<span class="string">"这是词频矩阵："</span>)</span><br><span class="line">    print(matrix.toarray())</span><br><span class="line">    </span><br><span class="line">    word_tf_idf = tf_idf.fit_transform(matrix)</span><br><span class="line">    print(<span class="string">"这是tf-idf矩阵："</span>)</span><br><span class="line">    print(word_tf_idf.toarray())</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是词袋：</span><br><span class="line">[<span class="string">'人往'</span>, <span class="string">'悄悄'</span>, <span class="string">'成为'</span>, <span class="string">'玫瑰色'</span>, <span class="string">'花香'</span>, <span class="string">'过往'</span>]</span><br><span class="line"></span><br><span class="line">这是词频矩阵：</span><br><span class="line">[[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">这是tf-idf矩阵：</span><br><span class="line">[[<span class="number">0.57735027</span> <span class="number">0.</span>         <span class="number">0.</span>         <span class="number">0.57735027</span> <span class="number">0.57735027</span> <span class="number">0.</span>        ]</span><br><span class="line"> [<span class="number">0.</span>         <span class="number">0.57735027</span> <span class="number">0.57735027</span> <span class="number">0.</span>         <span class="number">0.</span>         <span class="number">0.57735027</span>]]</span><br></pre></td></tr></table></figure><h2 id="4-不足"><a href="#4-不足" class="headerlink" title="4. 不足"></a>4. 不足</h2><p>TF-IDF 采用文本逆频率 IDF 对 TF 值加权取权值大的作为关键词，但 IDF 的简单结构并不能有效地反映单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能，所以 <strong>TF-IDF 算法的精度并不是很高</strong>，尤其是当文本集已经分类的情况下。</p><p>在本质上 IDF 是一种试图抑制噪音的加权，并且单纯地认为文本频率小的单词就越重要，文本频率大的单词就越无用。这对于大部分文本信息，并不是完全正确的。IDF 的简单结构并不能使提取的关键词， 十分有效地反映单词的重要程度和特征词的分布情 况，使其无法很好地完成对权值调整的功能。尤其是在同类语料库中，这一方法有很大弊端，往往一些同类文本的关键词被盖。</p><h6 id="TF-IDF算法实现简单快速，但是仍有许多不足之处："><a href="#TF-IDF算法实现简单快速，但是仍有许多不足之处：" class="headerlink" title="TF-IDF算法实现简单快速，但是仍有许多不足之处："></a>TF-IDF算法实现简单快速，但是仍有许多不足之处：</h6><p>（1）没有考虑特征词的位置因素对文本的区分度，词条出现在文档的不同位置时，对区分度的贡献大小是不一样的。</p><p>（2）按照传统TF-IDF，往往一些生僻词的IDF(反文档频率)会比较高、因此这些生僻词常会被误认为是文档关键词。</p><p>（3）传统TF-IDF中的IDF部分只考虑了特征词与它出现的文本数之间的关系，而忽略了特征项在一个类别中不同的类别间的分布情况。</p><p>（4）对于文档中出现次数较少的重要人名、地名信息提取效果不佳。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Keyword Extraction by TextRank</title>
      <link href="/2019/08/01/Keyword-Extraction-by-TextRank/"/>
      <url>/2019/08/01/Keyword-Extraction-by-TextRank/</url>
      
        <content type="html"><![CDATA[<h1 id="Keyword-Extraction-by-TextRank"><a href="#Keyword-Extraction-by-TextRank" class="headerlink" title="Keyword Extraction by TextRank"></a>Keyword Extraction by TextRank</h1><h2 id="1-Understand-PageRank"><a href="#1-Understand-PageRank" class="headerlink" title="1. Understand PageRank"></a>1. Understand PageRank</h2><p>TextRank是一种基于PageRank的算法，通常用来进行关键词抽取和文本摘要生成。PageRank是一个用来计算网页权值的算法，我们可以把网络上的所有网页认为是一个巨大的有向图，一些网页指向另外一些网页，而在图中，一个结点就对应一个网页。如果网页A有通向网页B的连接，则这个连接就可以被认作一个从A到B的有向边。</p><p>当我们构建完一整张图以后，我么可以为网页分配权值，使用以下公式：</p><script type="math/tex; mode=display">S(V_i) = (1-d) + d * \sum_{j\in In(V_i)} { {1}\over{|Out(V_j)|} }S(V_j)</script><blockquote><p>$S(V_i)$ - the weight of webpage i</p><p>$d$ - damping factor, in case of no outgoing links</p><p>$In(V_i)$ - inbound links of i, which is a set</p><p>$Out(V_j)$ - outgoing links of j, which is a set</p><p>$|Out(V_j)|$ - the number of outbound links</p></blockquote><p>下面用一个例子来讲述PageRank的实现过程。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARoAAAEWCAYAAAC5cVjBAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAACAISURBVHhe7Z1brFXV9YcngiAgt4PcitwRUIugglpQCk0LGtOoJEb7YOJT32yT1jR9sQ99atqHJu2br20a+0C1taYt/UdpK8hNK1gBQQSRiwhyUzhwEPzPb+01DovtOod9WWuvufb+fcnIupyjZ23O3r8z5hhjjjHgS48TQogcuS4+CiFEbkhohBC5I6ERQuSOhEYIkTsSGiFE7khohBC5I6ERQuSOhEYIkTsSGiFE7khohBC5I6ERQuSOhEYIkTul31R50tvH3o566+GG53NvZyunbri3GyunbrC3Cd4mehvDDSFESyil0Oz19pG3pLjUi4nOFG+zuCGEyI3SCM1FbztjS4oL5+e84cHwPcDRzq+PDTji4QzzhtAYnN8am32vECI7SiE0273t8Gbi0e3thDcExu7VC4KC4HR5G8oND/du83ZHdCWEyIqghYZYyzpvxGEAr+WYNwQmSxCccd7wdoD4zXJvFtsRQjRHsEJDHGarN5ZG2GFvWQtMNQjO17yxlMIWeVP8RojmCVJotnjbVTl1Z7wd8XYpusqfgd4meRsZXTm3wJuWUkI0R3B1NHgyJjKHvB301iqRAX4WP5OfDdu88UxCiMYJSmj4QG+onEYf9NOV00LgZ5vY8EwSGyEaJxihoS4mFJExqsWGZxRC1E8QQkOK2kSGrFIIImPwLDwT8IyNptOF6GSCEBorwrP0dWjwTDwbz8izCiHqo3ChoVaGgCuwpSBU7Nl4Vp5ZCFE7hQsNtTJwytv5ymmQ8Gw8I9gzCyFqo1ChwTMgwHrZW8jejMESimflmeXVCFE7hQqNZXEoymtlrUyjEAjmWUEZKCFqJwih+Sw+ZsXxDRvcP++912186il34Vi24WV7VgmNELVTmNDgHdhyKcs9TF9euuSOr1/vBo8a5c7t3+9OvvVW/JVssGfl2ZXqFqI2ChOaA/Ex62VT95Ej7vgbb7jJjz7qRs2f7z7dtMld7iExnQ08q3Xvs9cghOifwoTGPqwX4mNWnHn3Xdfjl0s3LV3quhYtipZRZz/8MP5qNphXY69BCNE/hQnNp/Exy5T2pXPn3NH/+z934+zZbtjUqa7rnnvcpbNn3bF//9uvqbLbpG7PbK9BCNE/hcZoIMtl07lDh9ypd95xN91/vxs8erQbPm1atHw6/vrrrueUVcE0jz2zYjRC1EZhQpMHJ7dujTwYlkxuwAA3aMQIN+6BB9zpHTvcmZ3aPCBEURQmNFlnnC6eOeM++de/3Mjbb3fDZ8yI7zo35q673PUjR0ZLqqyCwhZXshajQoj+aRuP5uy+fVEguGvxYne992SMYVOmuDELF7oTmze7br+0ygJbOiFb27dvd2e8yAkh+qawVp6/i49MN2gWamd2/+Y37sPf/z6+k86tP/2pm/L44/FVczAt4cuDB5179dXoeqEXszvuUNNPIdIoTGjWemP5tN9bs8snqn//+6MfucsXLrhxy5a56wYNir9S4dL58+7I3//uhk+f7hb88pfRUqoZaGI+3RsTL6ft3u3efPNNd/HiRTfCe1JLly5148eP59uEEDFtITTHXn/d/feHP3Tznn3WTf3e9+K7VyA2s/MXv3CHX3nF3fnrX7ubliyJv9IYJjRMulzprbu7223cuNF99FFlY8Itt9ziFi1a5K6/XuPohIDCYjT2EWTqQDMgIp/45cuQcePcGLJNKVw3eLCb8O1vR+dUCrPUagZ7ZnsNQ4cOdStWrIiM8z179riXXnqpV3iE6HQKE5qx8fGG+Ngo5z/5xJ18+203ev58N2zy5PjuVxnhvYwRc+a4Y//5T7RNoRnsme01GFOmTHGPPvpo5NHg5bz22muRnT2rGmLR2RQmNDYVckh8bJRP33jDnfvww6hIb+AwFjXpDLnpJjd++fLoe/lvmsF+ir2GJCyXvvGNb7gHH3wwitng1fz5z392O3bscAWtUoUonMJiNFTVvlA5de95y7JCOE9YNs2tnLonvfUXhbl8+bLbtm2b+9///heJzNixY6Ng8ejRo+PvEKIzKHRSpQWEiWRk3ZMmL6jQmeLNAsG1cOrUqShY/Ilf5g0YMMDdfvvtUTr8uuvapoxJiH4pVGjYFED/XXYhMVu7DDCbG3+EsPOt3KiD3UqFiw6lUKGh7+6L3ujDu8db6MsnlkkM/ccPeczbjd7qJS0Vftddd7khQ5qNVgkRLoUKDbzmjVnXZfBqzJu52dsKbjQBQoPgIDyIzOLFi93MmTPjrwrRXhQuNObVwAfeQh25YkV60Kg3Uw1LqK1bt0Z1NzBp0iS3ZMkSN3x4Wj5LiPJSuNDAdm8MZqPaJNteeNkxzRsf/wXest7RRJB4/fr17rPPPnODBg2KAsW33nprFDgWoh0IQmhIdf/JG7uhmVkQ2lhcMkwU5w32ttpbHhsL0lLh9913X3QUouwEITRAaHRd5dTRzCGUQf+jvFm98XJvpLbzhFQ43s2nn1YaheLZ3HnnnZGnI0RZCUZoYK+3DZXTIMQmKTJswyTj1Ar4lRC3sVQ4MRtiN8RwhCgjQQkNhCI2RYlMkupU+IwZM9w999yjVLgoHcEJDWzxtqtyGs19Ygtkq2ps2GKA32Ada/II/taLUuGi7AQpNIBng+AQKCZITI1NVv2F+4IUNrUyBH0J+C71lndMplbSUuEEi6kwFiJ0ghUaoMaGALE1ASf9TUYqa8FBYMZ5s+qVMd4I/GZRK5M1yVQ4e6VoH/r1r39d+6ZE0AQtNAZ1NvQWtjlK3d5OeENwGp2thMeCwHR5G8oND/foBRx659/qVDi7wdk3pVS4CJVSCA0gKGzCfN9bso0Uyyquk6LD0c4RD6t7MXHBc2F5ZHA92xubJO17y4BS4aIslEZokhC/YcD+J94andSE0LBveqq3IjJKWcGvb+fOne7tt992X3zxhVLhIkhKKTRJiN98HJt5McR2zOvBW7FYC94Kkwsw4jDtBO1CN2/efFUqnAbp9DAWomhKLzTiapKpcNqK3n333W7OnDnxV4UoBglNG1KdCqe5FsFipcJFUUho2hilwkUoSGjanLRUOIV+aiEqWomEpkOoToVrmqZoJRKaDoJfdTIVTkYK74bBd0LkiYSmAyEVvmHDBnckntiJ0CA4SoWLvJDQdDAHDhxwmzZtUipc5I6EpsNJS4Xj3WiapsgSCY2ISKbCNU1TZI2ERvRSnQrXNE2RFRIa8RWUChdZI6ERqfC2UCpcZIWERvRLWiqcBumapinqQUIjauKDDz5wW7ZscRcuXNA0TVE3EhpRM4jMW2+91ZsKp3UowWKlwsW1kNCIulEqXNSLhEY0RFoqnGCxWoiKNCQ0oimqU+GapinSkNCIpuEtlEyFa5qmqEZCIzKjOhXOMoqJDEqFCwmNyBylwkU1EhqRC2mpcILFmqbZmUhoRK4kU+GgaZqdiYRG5E51Krxdp2naMMOj3myCal/DDJmUOsFbOw4zTENCI1pGO6bCGc/MbNCkuNSLiQ7bVcs8nrk/JDSipfB2K3sqnNHLO2NLigvn57zhwdh4Zo52TpMNa7TBEQ9nmDeExuD81tjaqSmHhEYUQnUqvCzTNLd72+HNxKPb2wlvCIzdqxcEBcHp8mbt4bl3m7c7oqvyI6ERhZJMhYc8TZNYyzpvxGEAr+WYNwQmSxCccd6s8oj4zXJvFtspKxIaUTiIzObNm92+ffuia3aD492EkgonDrPVG0sj7LC3rAWmGgTna95YSmGLvJU5fiOhEcHAMmrjxo1BpcK3eNtVOXVnvLHQuxRd5c9Ab+TlRkZXzi3wVtallIRGBEVaKpzMVBEtRPFkNlRO3SFvpyunLWeUt8mVU7fEWxk9GwmNCJLqVHirp2mGIjJG2cVGQiOChbdmMhXeqmma1MUQ+IUQRMZIig0B4jK1iZfQiOBpZSqcFPWfvBH0JauEhQQZKYwA8WpvZam1kdCI0lBPKvzjjz92PT09burUqfGd2qBOZps30tcfciNApnkj/V2m4LCERpSKtFQ4sZvkNE0E5uWXX46+98EHH3RdXZTCXRtqZV6snLoPvJ2vnAbHDd6sjvoxb2WosZHQiFLCMorlFMsqSE7TxOshtgNkrb773e+6wYOThf7pEJchPnPKG7UyIUONDbMniNMQrwkdCY0oLQSI33nnnd5UOBkpJjJs3Up53RUmTJjgVq1aFV+lY97MZW900GlVrUyjEJsh88SisQxejYRGlJ7qVLjBW9u6+s2aNSsKIPcF/g/yVAZvxjCvhqphNmGGjIRGtAW8jdetW+c++ojFzxWRSYoNQoPgpLHWG60e+K8rdcmNcXbfPvfWM8+47jhD1h+Ln3/ejbn77viqfsi5sXSixcRKbgSMhEa0BZ9//rn7y1/+Ei2nkuJSzcqVK93EibSbugIp7Rcqp+49b80sm0xoBg4b5sYtW+au62f7xMSHHnLDp5FDagy2KMytnLonvYWc6pbQiLbgH//4hzt69Gi/IgMEi4nXJDNRVgXMXqaD3GgCE5rRCxa42557zg28gRxRfliqO/RqYc0wFaXnwIEDkciALZfs72f139GLFy9G8RxS4Ia12rwQH8uE7SK31xAqEhpRelgKLV++PNrtPWbMmEhszKtJE56TJ0+6V199NboGCyGHWjfTH/bMV4fBw0NCI0oPNTJUANMSlJqZ1atX9wZ+qaOpFh5gOgPBY7DOeKGntNOwZ260u1+rUIxGtD0EillasS3h8OHDrrubBpwVEKS9XpBYeO331mxDq1qzTjOeftrd4r+vWWiQNd1b6JknCY3oOBCe3bt3u9OnT0fi8wXFfF1dUS/gZqk16zRi7lw3fsWK+KpxLPNE3fMT3AgUCY3oWAgIE69Zy3Jq/PhMhaZVWSegiTk8FR9DREIj2hYTEo4nTpyIjseOHYtahbLhEggen8KjGTxYQpMjEhpRekhvVwsK19di8uTJ7oEHHnDrvMhkHaNpldCUJUajrJMoPezWps8wO7YJ+tYiMmy0/Na3vlXTrm7RPBIaUXoWLlwYn1XqZK7lpJP2pjrYUt1Wuk9gtWzYM4feaU9LJ9EWrFmzprc3TX+k7eK2rnpZtO6sNesEWWSerLVn6N32JDSi9DCiZdOmTW7Pnj2RN2OeSjULFiyIrJo89jrVsns7i1qasux1ktCI0sJObcTl3XffdefOXQnjpolNfy0isty93Uq0e1uIHCE1vWvXrsgsTU1Ql1R12g7u/kTGyKofTStRPxohcgCvBe8FLwZvBoYNG+Zuu+22aNYTSyhiNezQNmoRGVCHvXyR0IjgOXPmTNQXeO/evb0ZpZEjR0ajVmbOnHnVuBXS3BjzuhuZgKCewfkgoRHBQg9gmo9TkGeMHTs2Ehh2a6cFfSnWw6upbm5VC695IxhcpikIN3trfsdU/khoRHAwSgWBYcOjQc+Z+fPnu0mTJsV3+gaxaaQQryxznawaGDTXSYg64G1IY3EEJjnNAM8FgcGTaQWaVJkPEhpRKARwGXVLDIZYDLAkIvaCwBCLaSWEkUOevU2GCcnV7G0haiCtBoYALhMnGQJHNqkoSHFXeu85d8jb6cpp4YzyNrlyGk2nJLVdFiQ0oqX0VQNDv9958+a5IUOGRPeKxqqFIQSxSYpM6FXAaUhoREs4f/58FH/pqwYGbyY0QhGbsosMSGhErtA2k/jL+++/H8VjYPTo0VH8Zdq0aVfVwITIFm+7KqfRXih2MLWqxoYtBuTYLEpVpuBvNRIakQv0hEFg9u/f31tkN378+KgG5uabqf4oD3g2CA6BYoLE1Ng02yDrWhCholaGoC8BX/ablykmU42ERmQKY0xYIh06xGKjAp3s8GAQmrJCjQ0BYmupRfqbjFTWgoPA0PaB9DWM8Ubgtwy1Mv0hoRGZgLAgMAgNkKKePn165MGw2bFdoM6G3sK2m4rBLSe8IThXdljVBx4LAkMd81BueLhHL+CyLpWqkdCIhuGtw9KIJZK1zyTmMnv27Ehgbryx7H+H00FQ2IT5vrdkqy2WVVwnRYejnSMeVvdi4oLnkqxh5nq2NzZJ2ve2AxIaUTeXLl2KgrvUwBDsBYbnz507N8oi3dCCzv+hQPyGnVj4cVemedcHQsOicqq3MmaUakFCI2qG9gvvvfee27FjR5SuBkQFcUFkEJtOBp+O3VmYeTHIsHk9eCvm4/EvNTG29llY9o2ERlwTRAVxQWSs1wvLIip4WSYNHFjGtt6ilUhoRJ/0VwNDoDetTYMQaUhoxFdIq4Gpp02DENVIaEQvaTUwrW7TINoTCY1IrYEpqk2DaE9KLzQW6aeDvaUX+4r0k0akn0enRPr7g197dQ1MKG0aRPtRSqGhdoGeIUlxqRcTHfaPtGvtQhppNTAhtmkQ7UVphIakKtWYWFJcOKcSEw/Gahc42jn1ClbdwREPh7/VyWpMzqnEbLdqzCRpNTCht2kQ7UMphEb7SxonrQamr1ElQuRF0EKjHbONQ3vM7du3X1UDc61RJULkRbBCQxyGyYEsjbBW9wDBmABYtvhN2rA11cCIoglSaNTVrH7Shq2pBkaEQnBCoz6t9VE9bM3aNBDkVQ2MCIWghCYUkTFCFRt+ZdXD1jq1TYMoB8EIjWbpXJu0YWtq0yDKQBBCQ9I15OmAZKQwAsRFTAdMG7amNg2iTAQhNJp3nE7asDW1aRBlpHChoVbmxcqp+8BbpWY1PIh6zKycuse85Vljg9eC95IctlbWUSVCQOFCQ1yG+Mwpb9TKhAw1NqO9EachXpM1aTUw7TCqRIhChca8GepW93hrVa1MoxCbIfNE0X6WXk11DUy7jioRnUuhQsMGSap/y+DNGObVUDXMJsxm6KsGpp1HlYjOpFChWeuNVg8snT7jRoOc3bfPvfXMM67bf3CrGTJ2rBv3zW+6GU8/7Yb6ZUizjPDG0okWEyu5USf8c1fXwFibBlLUqoER7UhhQkNK+4XKqXvPWzPLJhOaIePHu7H33BPfrfDZnj3u+IYN7oZJk9zCX/3K3TirubI7EslzK6fuSW+1prrTamDUpkF0CoUJjVUB85E7yI0mMKGZuGqVu8Ufq/n0jTfctp/8xE1evdrN+cEP3IAm604s1V1LtXBaDYzaNIhOo7B3ubXarFSH5MtIvywZ7j/UPcePu8txT5ZmsF3k9hrSoO5l27Ztbs2aNW7Lli2RyLC58Zt+GffII49EsRiJjOgUCnunV6ITrambudzTEwnMwKFDm/ZmwJ7ZXkMSBAVhQWAQGgSHNg3f+c533MMPP+ymTZumQjvRcRQmNOZX5J3SvnjmjPvwD39w548ccZMeeshdl8F+IHvmpG9E/90NGzZEArNz585oyUSbBsRl5cqV6gUjOprCYjSWcdrvrdmGVv1lnWDIuHFu/s9/7roWL/avuHlvggZZ072ReVpcNWxNo0qE+CqFCc3v4iO9gJulv6zTuUOH3PHXX488mbnPPusm+iVMs2JjmadBx465i3/7W3RPo0qE6Ju2Epq+sk7njx517zz3nDt/+LC767e/dcNnzIi/0jg0MYfBf/xjVL173333yYMRog86Iu1xw4QJ7msPPxwtrU6+/XZ8t3m+9B4NwV4qe//617/2ZpeEEFdTmNAQ34BWLTKGxbueuw82W7Vz5ZkneE9m0aJF0VKJ4C9BYILBBIWtKE8I0SEeDZyLBYZ6mqwYMGhQVNm7evVqt2TJkmjpxEqUEScvvfSSW7duXe82AyE6mcKExpLMregNd+H4cXf4lVei7NOIOXPiu41jz2yvwTZDUohHQZ5NHWA39iv+565du7Z3gL4QnUhhwWDrqpdF687+sk49J0+6j/0H/Ytz59y8H//YTXn88aazTtbas79uewgLGycPHaIDcgV6ypD2pseMEJ1EW+11Squjud4vZ8bee6+b8sQTbvSCBW5ABmX/9ex1OllVZwNkqdjrpHacolMoTGiy3L3dSqyGBurZvU3lMIKTHFGrBuOiUyhMaCCrfjStpNl+NGlD9zUyRbQ7hQpNJ3fYQ2QQG0QH8QENgRPtSqFCo57B/jVfuhQtp+hXw/IK1NJTtBuFCg285o1gcJmmIFD6t4IbGcKvgYAxmapTp/jX8L+cAWpSLtqDwoWmLHOdbMc25D3X6eDBg1HgOFl7o7EroswULjSgSZXpqBZHtAtBCA25l5Bnb5Nhota3qNnbqsURZScIoQFS3EytBP5+n66cFs4ob+Y7MJ2S1HZRECxm42ZyVK5qcUQZCEZowKqFIQSxSYpMLVXArSJt+L9qcUTIBCU0EIrYhCoySfBqdu/eHdXiWB8c1eKIEAlOaGCLt12V02gvFDuYWlVjw+KDNuLWK6+Vwd9GSRtOp1ocERJBCg3g2SA4BIoJElNjk3fvOlLY1MoQ9GXxsdRbkTGZeuFXSWsKBMf64KgWR4RAsEID1NgQID4ZXVXS32SkshYcBIa2D6SvgY8jgd8y+wFHjhyJUuO0GTVIiS9cuLC3X44QrSJooTGos6GJuc1R6vZ2whuCY/fqBY8FgenyNpQbHu7RdDz0pVI94NkgOHg6BgPtqMXRrCnRKkohNICgsAnzfW/JUbQsq7hOig5HO0c8LAdj4oLnwvLI4Hq2NzZJ2ve2G8RuEBxiOfYrx7NBcKZMmaJaHJErpRGaJMRv+PtMgT5C0wgIDcX8U72FmFHKC7JTbOBM1uLQ65gYDoPvNA9c5EEphSYJ8RuiEJh5McR2zOvBW7FYC97KxNg6PSxK/Q1ik2xTwTQHiv8YhMdAPCGyovRCI5ojrU3FkCFD3Lx58yLjXIhmkdCICN4G1W0qNOZXZIWERnyF6jYVBIpnzZoVxXE09lc0goRG9Elam4qpU6dGmSrV4oh6kNCIa5LWpkK1OKIeJDSiZtJGxqgW5wqWAWWyh5Vd9JUBpbyCPkedkgGV0Ii6SRsZ06m1ONR00UspKS71YqLDvrp2remS0IiGSRsZ0wm1OEgrVepYUlw4p0IdD8ZqujjaeXWVOh4OubxklTrnVKi3W5W6hEY0TSfV4mjfXWNIaERm8FaqblPRLrU46iTQHBIakQvVbSrKXItDHIaJqiyNsFb3RsKYjFrm+I2ERuRKWpsKanEWLFhQikZc6vaYDRIa0RLS2lSEPhRP/auzQ0IjWkpam4oQh+KFIjJG2cVGQiMKIW1kTChD8TRjLHskNKJQ0kbGFDkUjxR1yFNTyUhhBIiLmJraKBIaEQRpI2OKGIqnOfD5IKERQcHbsboWp96heD09PW7w4GS9bW1QK/Ni5dR94K1S6xwe/AvMrJy6x7yVocZGQiOCpboWp5aheIjMyy+/7FasWOG6uqi1rR3iMsRnaPtFrUzIUGMz2htxGuI1oSOhEcGDZ0MMx9pUECjuayjetm3bIsMLWrVqVc1iY94Me9L3eGtVrUyjsJAk88T21TJ4NRIaURrS2lQka3HwZtasWdO7o5ztD/fff39UIHgt2CBJ9W8ZvBnDvBqqhtmEGTISGlE60tpUIDTDhw93+/bti66TLF26NNr+0B9rvdHqgaXTZ9xogpNvvum2fP/78VXfLH7+eTfm7rvjq/oZ4Y2lEy0mVnIjYCQ0orSktakA3tLVdTj9iQ1S9ULl1L3nrdllkwnNuGXL3Mi5c+O7X2XiQw+54dPIITUGiX/7vz/pLeRUt4RGlB7aVGzcuNHt3Us9b9/0JTZWBUxS/SA3msSE5vaf/cxNfuSR+G4+WKo79GphjSUUpYeiPstM9cf69evdli1sk7waa7VZqU8uF7aL3F5DqEhoROnBkzl79mzvZs3+nPSdO3dGgpOkUq0Tbt1Mf9gz22sIFQmNKD3EaMDiMnZEcJKiY+cI07p1tpvpSme80FPaadgz22sIFcVoROlBOEh9Jw0P51pQi7Ns2bLejNN+b1k0tKol69RsxsmgQdZ0b6FnniQ0om1Jio6dnz59Ohr5ay0qKPg7tWqVc4MHR72As6CWrFOzGSfDMk9suHiCG4EioREdi4nPP9kX1dWVudC0IusENDGHp+JjiChGIzoW9ksxcROREfkioREdD/ENKOOMBntmew2hIqERQuSOhEZ0PFa639peftlgzxx6pz0Jjeh4xsbHa7fUCg97ZnsNoSKhER2PTYUs4+Bei9HYawgVpbdFx5P17u1WUabd2/JoRMfDB7SMmadkxkkxGiFKgM1IoplUWbBnLcN8JwmNEB77sDLnugzZJzwYm8ktoRGiJNDc+2ZvfCBCL34DhsjxrDxzGcatSGiEiFkcH2n4HXKqm9gMzwj2zKEjoREiBs+A6Y8QsleDNwM8axm8GZDQCJGAsSW0XKAuxT7QIYEA8mw8Y+gjVpJIaIRIQJCVRt+A0IyqnAYBz2IVwDxj6CntJBIaIaogi2NiM9lbCGLDM/AswLOVIdOUREIjRAqMLglFbKpFJuSxKn0hoRGiD/hAz6ucRh90UsmtrLHhZ/EzTWQI/pZRZEB7nYS4BgyYYxoUe6J6vDGbO4sm5v1BCpvZ2gR9icUs9Va25VISCY0QNfC5Nwa0nIyuKgPbjnnLWnAQGILQtht7jLfl3sqSxu4LCY0QdbDdG03MbY5St7cT3hCcRmcr4bEgMHQuHsoND/doOn5HdFV+JDRC1AmCstPb+96S06NYVnGdFB2Odo54WEraxMVqYgyuZ3ujRsa+tx2Q0AjRBMRvDnj7xBtC0wgIzXhvU72VNdh7LSQ0QmQE8ZuPYzMvhtiOeT14KxZrwVuZGBtxmHZHQiOEyB3V0QghckdCI4TIHQmNECJ3JDRCiNyR0AghckdCI4TIHQmNECJ3JDRCiNyR0AghckdCI4TIHQmNECJ3JDRCiNyR0AghckdCI4TIHQmNECJ3JDRCiNyR0AghckdCI4TIHQmNECJ3JDRCiNyR0AghckdCI4TIHQmNECJ3JDRCiNyR0AghckdCI4TIHQmNECJ3JDRCiNyR0AghckdCI4TIHQmNECJ3JDRCiNyR0AghckdCI4TIGef+H3JN2pCsuGwTAAAAAElFTkSuQmCC" alt="iamge"></p><p>我们可以用上面的有向图来表示网页之间的连接关系，下图中表示A有一个结点指向E，B有两个结点指向E，我们可以使用邻接矩阵来表示这个有向图。</p><p>每一行中的顶点对应的值表示从其他顶点连入该顶点的连接数，即该顶点的入度，同样地，每一列中的顶点对应的值也即该顶点的出度——即该顶点连接出去的数目。</p><div class="table-container"><table><thead><tr><th></th><th>A</th><th>B</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>E</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>F</td><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div><p>根据公式${1 \over {Out(V_j)}}$，我们应对上述的矩阵作标准化处理，<font color="red">这一步对矩阵所做的处理，实际上也就是将矩阵转换成马尔可夫的转移概率矩阵，通过Markov Chains(实际上网页之间的连接就是一个Markov Chains)的性质来得出最终收敛结果(即该Markov Chains的平稳分布)，也就是我们需要的PageRank。</font></p><div class="table-container"><table><thead><tr><th></th><th>A</th><th>B</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>E</td><td>1</td><td>0.5</td><td>0</td><td>0</td></tr><tr><td>F</td><td>0</td><td>0.5</td><td>0</td><td>0</td></tr></tbody></table></div><p> 然后，我们令所有节点的默认权值为1，完成$\sum_{j\in In(V_i){1\over|Out(V_j)|}S(V_j)}$ 的运算，具体如下：</p><script type="math/tex; mode=display">\left[\begin{matrix}    0 & 0 & 0 & 0\\    0 & 0 & 0 & 0\\    1 & 0.5 & 0 & 0\\    0 & 0.5 & 0 & 0\end{matrix}\right]*\left[\begin{matrix}    1\\    1\\    1\\    1\end{matrix}\right] = \left[\begin{matrix}    0\\    0\\    1.5\\    0.5\end{matrix}\right]</script><p>最后，经过多次迭代直到收敛，就可以得出最后的权值。因为我们预先并不知道node的最终权值，因此，具体的收敛实现则可以用相近两次的权值总和(sum(pagerank))之差来表示，如果这个差小于0.00001，就认为收敛了，即权值就是最终权值。</p><h2 id="2-使用TextRank实现Keyword-Extraction"><a href="#2-使用TextRank实现Keyword-Extraction" class="headerlink" title="2.使用TextRank实现Keyword Extraction"></a>2.使用TextRank实现Keyword Extraction</h2><p>PageRank和TextRank的基本思想是一致的，在PageRank中，node是网页，而在TextRank中，node则是单词。在关键词抽取中，我们可以把一个文本分割成许多句子，然后我们存储这些句子中特定词性的词，因为句子中的大多数单词对决定句子的重要性并不是那么有用，我们只考虑名词(NOUN)，专有名词(PROPN)，动词(VERB)等词性，当然这是可以选择的，你也可以使用所有的单词。</p><p>例如，我们使用这样一段文本，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># e.g.1 将整段文本分割成几个句子 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="comment"># 导入en_core_web_sm模型</span></span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_sm'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实验文本</span></span><br><span class="line">content = <span class="string">'''</span></span><br><span class="line"><span class="string">The Wandering Earth, described as China’s first big-budget science fiction thriller, quietly made it onto screens at AMC theaters in North America this weekend, and it shows a new side of Chinese filmmaking — one focused toward futuristic spectacles rather than China’s traditionally grand, massive historical epics. At the same time, The Wandering Earth feels like a throwback to a few familiar eras of American filmmaking. While the film’s cast, setting, and tone are all Chinese, longtime science fiction fans are going to see a lot on the screen that reminds them of other movies, for better or worse.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文本转换为一个nlp对象</span></span><br><span class="line">doc = nlp(content)</span><br><span class="line"><span class="comment"># 打印文本中的句子</span></span><br><span class="line"><span class="keyword">for</span> sents <span class="keyword">in</span> doc.sents:</span><br><span class="line">    print(sents.text)</span><br><span class="line">    </span><br><span class="line">[out]:</span><br><span class="line"><span class="comment"># 实验文本被分成了三句话</span></span><br><span class="line"></span><br><span class="line">The Wandering Earth, described <span class="keyword">as</span> China’s first big-budget science fiction thriller, quietly made it onto screens at AMC theaters <span class="keyword">in</span> North America this weekend, <span class="keyword">and</span> it shows a new side of Chinese filmmaking — one focused toward futuristic spectacles rather than China’s traditionally grand, massive historical epics.</span><br><span class="line"></span><br><span class="line">At the same time, The Wandering Earth feels like a throwback to a few familiar eras of American filmmaking.</span><br><span class="line"></span><br><span class="line">While the film’s cast, setting, <span class="keyword">and</span> tone are all Chinese, longtime science fiction fans are going to see a lot on the screen that reminds them of other movies, <span class="keyword">for</span> better <span class="keyword">or</span> worse.</span><br></pre></td></tr></table></figure><p>如果要进行关键词的抽取，那么主要包括以下几个内容：</p><ul><li>文本分割成句子，保存每一句中特定词性的单词(表征词 - tokens)</li><li>以每一句为单位，获得该句子中指定窗口大小的pair，最终得到整个文本的token_pairs集合</li><li>获得所有的tokens的集合，即该文本的表征词汇集合 - vocab</li><li>根据获得的vocab和token_pairs，来得到文本图的矩阵表示，并将矩阵归一化</li><li>迭代计算出每个token的weight</li><li>(可选操作)向STOP_WORDS中加入自定义的STOP_WORDS</li><li>对权值进行排序</li></ul><h2 id="pre-option"><a href="#pre-option" class="headerlink" title="pre-option"></a>pre-option</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">from</span> spacy.lang.en.stop_words <span class="keyword">import</span> STOP_WORDS</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">nlp = spacy.load(<span class="string">"en_core_web_sm"</span>)</span><br><span class="line">content = <span class="string">'''</span></span><br><span class="line"><span class="string">The Wandering Earth, described as China’s first big-budget science fiction thriller, quietly made it onto screens at AMC theaters in North America this weekend, and it shows a new side of Chinese filmmaking — one focused toward futuristic spectacles rather than China’s traditionally grand, massive historical epics. At the same time, The Wandering Earth feels like a throwback to a few familiar eras of American filmmaking. While the film’s cast, setting, and tone are all Chinese, longtime science fiction fans are going to see a lot on the screen that reminds them of other movies, for better or worse.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">doc = nlp(content)</span><br></pre></td></tr></table></figure><h2 id="1-文本分割成句子，保存每一句中特定词性的单词"><a href="#1-文本分割成句子，保存每一句中特定词性的单词" class="headerlink" title="1. 文本分割成句子，保存每一句中特定词性的单词"></a>1. 文本分割成句子，保存每一句中特定词性的单词</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentence_segment</span></span><br><span class="line"></span><br><span class="line">candidate_pos = [<span class="string">'NOUN'</span>, <span class="string">'PROPN'</span>]</span><br><span class="line">sentences = []</span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">    selected_word = []</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sent:</span><br><span class="line">        <span class="keyword">if</span> word.pos_ <span class="keyword">in</span> candidate_pos <span class="keyword">and</span> word.is_stop <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            selected_word.append(word)</span><br><span class="line">    sentences.append(selected_word)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> sentences:</span><br><span class="line">    print(sent, <span class="string">"\n"</span>)</span><br><span class="line">   </span><br><span class="line">[out]</span><br><span class="line">[Wandering, Earth, China, ’s, budget, science, fiction, thriller, screens, AMC, theaters, North, America, weekend, filmmaking, —, spectacles, China, ’s, epics] </span><br><span class="line"></span><br><span class="line">[time, Wandering, Earth, throwback, eras, filmmaking] </span><br><span class="line"></span><br><span class="line">[film, ’s, cast, tone, Chinese, science, fiction, fans, lot, screen, movies]</span><br></pre></td></tr></table></figure><h2 id="2-以每一句为单位，获得该句子中指定窗口大小的pair，最终得到整个文本的token-pairs集合"><a href="#2-以每一句为单位，获得该句子中指定窗口大小的pair，最终得到整个文本的token-pairs集合" class="headerlink" title="2. 以每一句为单位，获得该句子中指定窗口大小的pair，最终得到整个文本的token_pairs集合"></a>2. 以每一句为单位，获得该句子中指定窗口大小的pair，最终得到整个文本的token_pairs集合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get_token_pairs</span></span><br><span class="line"></span><br><span class="line">token_pairs = []</span><br><span class="line">window_size = <span class="number">4</span></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> sentences:</span><br><span class="line">    <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(sent):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> (i+<span class="number">1</span>, i+window_size):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= len(sent):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pair = (word, sent[j])</span><br><span class="line">            <span class="keyword">if</span> pair <span class="keyword">not</span> <span class="keyword">in</span> token_pairs:</span><br><span class="line">                token_pairs.append(pair)</span><br><span class="line">print(token_pairs)</span><br></pre></td></tr></table></figure><p>​        [output]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(Wandering, Earth), (Wandering, budget), (Earth, China), (Earth, science), (China, ’s), (China, fiction), (’s, budget), (’s, thriller), (budget, science), (budget, screens), (science, fiction), (science, AMC), (fiction, thriller), (fiction, theaters), (thriller, screens), (thriller, North), (screens, AMC), (screens, America), (AMC, theaters), (AMC, weekend), (theaters, North), (theaters, filmmaking), (North, America), (North, —), (America, weekend), (America, spectacles), (weekend, filmmaking), (weekend, China), (filmmaking, —), (filmmaking, ’s), (—, spectacles), (—, epics), (spectacles, China), (China, ’s), (’s, epics), (time, Wandering), (time, eras), (Wandering, Earth), (Wandering, filmmaking), (Earth, throwback), (throwback, eras), (eras, filmmaking), (film, ’s), (film, Chinese), (’s, cast), (’s, science), (cast, tone), (cast, fiction), (tone, Chinese), (tone, fans), (Chinese, science), (Chinese, lot), (science, fiction), (science, screen), (fiction, fans), (fiction, movies), (fans, lot), (lot, screen), (screen, movies)]</span><br></pre></td></tr></table></figure><h2 id="3-获得所有的tokens的集合，即该文本的表征词汇集合-vocab"><a href="#3-获得所有的tokens的集合，即该文本的表征词汇集合-vocab" class="headerlink" title="3. 获得所有的tokens的集合，即该文本的表征词汇集合 - vocab"></a>3. 获得所有的tokens的集合，即该文本的表征词汇集合 - vocab</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get_vocab</span></span><br><span class="line"></span><br><span class="line">vocab = OrderedDict()</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> sentences:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sent:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> vocab:</span><br><span class="line">            vocab[word] = i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">print(vocab)</span><br><span class="line">len(vocab)</span><br></pre></td></tr></table></figure><p>​        [output]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrderedDict([(Wandering, 0), (Earth, 1), (China, 2), (’s, 3), (budget, 4), (science, 5), (fiction, 6), (thriller, 7), (screens, 8), (AMC, 9), (theaters, 10), (North, 11), (America, 12), (weekend, 13), (filmmaking, 14), (—, 15), (spectacles, 16), (China, 17), (’s, 18), (epics, 19), (time, 20), (Wandering, 21), (Earth, 22), (throwback, 23), (eras, 24), (filmmaking, 25), (film, 26), (’s, 27), (cast, 28), (tone, 29), (Chinese, 30), (science, 31), (fiction, 32), (fans, 33), (lot, 34), (screen, 35), (movies, 36)])</span><br></pre></td></tr></table></figure><h2 id="4-根据获得的vocab和token-pairs，来得到文本图的矩阵表示，并将矩阵归一化"><a href="#4-根据获得的vocab和token-pairs，来得到文本图的矩阵表示，并将矩阵归一化" class="headerlink" title="4. 根据获得的vocab和token_pairs，来得到文本图的矩阵表示，并将矩阵归一化"></a>4. 根据获得的vocab和token_pairs，来得到文本图的矩阵表示，并将矩阵归一化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get_matrix</span></span><br><span class="line"></span><br><span class="line">vocab_size = len(vocab)</span><br><span class="line">matrix_for_text = np.zeros((vocab_size, vocab_size), dtype=<span class="string">'float'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word1, word2 <span class="keyword">in</span> token_pairs:</span><br><span class="line">    i, j = vocab[word1], vocab[word2]</span><br><span class="line">    matrix_for_text[i][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在关键词抽取中，我们把文本看做了一个无向图，无向图的矩阵表示是一个对称矩阵，以下就是无向图矩阵的对称化</span></span><br><span class="line">matrix_for_text = matrix_for_text + matrix_for_text.T - np.diag(matrix_for_text.diagonal())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对矩阵的每一列进行求和 -- 也就是该列顶点对应的出度总和</span></span><br><span class="line">norm = np.sum(matrix_for_text, axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># normalization以后的矩阵</span></span><br><span class="line">matrix_for_text = np.divide(matrix_for_text, norm, where=(norm!=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h2 id="5-迭代计算出每个token的weight"><a href="#5-迭代计算出每个token的weight" class="headerlink" title="5. 迭代计算出每个token的weight"></a>5. 迭代计算出每个token的weight</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># analyze()</span></span><br><span class="line"></span><br><span class="line">min_diff = <span class="number">1e-5</span></span><br><span class="line">d = <span class="number">0.85</span></span><br><span class="line">iterations = <span class="number">10</span></span><br><span class="line">tr = np.array([<span class="number">1</span>] * vocab_size)</span><br><span class="line">print(tr)</span><br><span class="line">previous_tr = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(iterations):</span><br><span class="line">    tr = <span class="number">1</span>-d + d*(np.dot(matrix_for_text, tr))</span><br><span class="line">    <span class="keyword">if</span> abs(previous_tr - sum(tr)) &lt; min_diff:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        previous_tr = sum(tr)</span><br><span class="line"></span><br><span class="line">print(tr)</span><br></pre></td></tr></table></figure><p>​        [output]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[0.72611111 0.91529514 0.92414931 0.91352431 1.10772569 1.16616319</span><br><span class="line"> 1.08086806 1.04574653 1.0903125  1.03010417 1.03010417 1.0903125</span><br><span class="line"> 1.04574653 1.08086806 1.16616319 1.10772569 0.91352431 0.92414931</span><br><span class="line"> 0.91529514 0.72611111 0.9575     1.12395833 0.91854167 0.91854167</span><br><span class="line"> 1.12395833 0.9575     0.74116319 0.93034722 1.00442708 0.96428819</span><br><span class="line"> 1.19361111 1.33232639 1.19361111 0.96428819 1.00442708 0.93034722</span><br><span class="line"> 0.74116319]</span><br></pre></td></tr></table></figure><h2 id="6-对权值进行排序"><a href="#6-对权值进行排序" class="headerlink" title="6. 对权值进行排序"></a>6. 对权值进行排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get_keywords()</span></span><br><span class="line"></span><br><span class="line">node_weight = dict()</span><br><span class="line"><span class="keyword">for</span> word, index <span class="keyword">in</span> vocab.items():</span><br><span class="line">    node_weight[word] = tr[index]</span><br><span class="line"></span><br><span class="line">node_weight_ordered = OrderedDict(sorted(node_weight.items(), key=<span class="keyword">lambda</span> t:t[<span class="number">1</span>], reverse=<span class="literal">True</span>))</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> node_weight_ordered.items():</span><br><span class="line">    print(k, <span class="string">" -- "</span>, v)</span><br></pre></td></tr></table></figure><p>​        [output]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">science  --  1.3323263888888888</span><br><span class="line">Chinese  --  1.1936111111111112</span><br><span class="line">fiction  --  1.1936111111111112</span><br><span class="line">science  --  1.1661631944444442</span><br><span class="line">filmmaking  --  1.1661631944444442</span><br><span class="line">Wandering  --  1.1239583333333334</span><br><span class="line">eras  --  1.1239583333333334</span><br><span class="line">budget  --  1.1077256944444445</span><br><span class="line">—  --  1.1077256944444445</span><br><span class="line">screens  --  1.0903125</span><br><span class="line">North  --  1.0903125</span><br><span class="line">fiction  --  1.0808680555555554</span><br><span class="line">weekend  --  1.0808680555555554</span><br><span class="line">thriller  --  1.0457465277777778</span><br><span class="line">America  --  1.0457465277777778</span><br><span class="line">AMC  --  1.0301041666666666</span><br><span class="line">theaters  --  1.0301041666666666</span><br><span class="line">cast  --  1.004427083333333</span><br><span class="line">lot  --  1.004427083333333</span><br><span class="line">tone  --  0.9642881944444444</span><br><span class="line">fans  --  0.9642881944444444</span><br><span class="line">time  --  0.9574999999999999</span><br><span class="line">filmmaking  --  0.9574999999999999</span><br><span class="line">screen  --  0.9303472222222222</span><br><span class="line">’s  --  0.9303472222222221</span><br><span class="line">China  --  0.9241493055555555</span><br><span class="line">China  --  0.9241493055555555</span><br><span class="line">Earth  --  0.9185416666666666</span><br><span class="line">throwback  --  0.9185416666666666</span><br><span class="line">Earth  --  0.9152951388888888</span><br><span class="line">’s  --  0.9152951388888888</span><br><span class="line">’s  --  0.9135243055555555</span><br><span class="line">spectacles  --  0.9135243055555555</span><br><span class="line">film  --  0.7411631944444443</span><br><span class="line">movies  --  0.7411631944444443</span><br><span class="line">Wandering  --  0.726111111111111</span><br><span class="line">epics  --  0.726111111111111</span><br></pre></td></tr></table></figure><p>具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">from</span> spacy.lang.en.stop_words <span class="keyword">import</span> STOP_WORDS</span><br><span class="line"></span><br><span class="line">nlp = spacy.load(<span class="string">"en_core_web_sm"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KeywordExtraction</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.d = <span class="number">0.85</span>         <span class="comment"># damping factor</span></span><br><span class="line">        self.min_diff = <span class="number">1e-5</span>  <span class="comment"># </span></span><br><span class="line">        self.steps = <span class="number">10</span>       <span class="comment"># iterate steps</span></span><br><span class="line">        self.node_weight = <span class="literal">None</span>  <span class="comment"># node_weight</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_stopwords</span><span class="params">(self, stopwords)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        添加自定义 stop_words</span></span><br><span class="line"><span class="string">        :param stopwords:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> STOP_WORDS.union(set(stopwords)):</span><br><span class="line">            lexeme = nlp.vocab[word]</span><br><span class="line">            lexeme.is_stop = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sentence_segment</span><span class="params">(self, doc, candidate_pos, lower=False)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        保存每一句中特定词性的单词</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">        sentences = []</span><br><span class="line">        <span class="keyword">for</span> sent <span class="keyword">in</span> doc.sents:</span><br><span class="line">            selected_words = []</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> sent:</span><br><span class="line">                <span class="keyword">if</span> word.pos_ <span class="keyword">in</span> candidate_pos <span class="keyword">and</span> word.is_stop <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    <span class="keyword">if</span> lower:</span><br><span class="line">                        selected_words.append(word.text.lower())</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        selected_words.append(word.text)</span><br><span class="line">            sentences.append(selected_words)</span><br><span class="line">        <span class="keyword">return</span> sentences</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_vocab</span><span class="params">(self, sentences)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        得到所有句子中特定词性的单词</span></span><br><span class="line"><span class="string">        :param sentences:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        vocab = OrderedDict()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> sent <span class="keyword">in</span> sentences:</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> sent:</span><br><span class="line">                <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> vocab:</span><br><span class="line">                    vocab[word] = i</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> vocab</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_token_pairs</span><span class="params">(self, window_size, sentences)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param window_size:</span></span><br><span class="line"><span class="string">        :param sentences:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        token_pairs = []</span><br><span class="line">        <span class="keyword">for</span> sent <span class="keyword">in</span> sentences:</span><br><span class="line">            <span class="keyword">for</span> i, word <span class="keyword">in</span> enumerate(sent):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, i+window_size):</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= len(sent):</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    pair = (word, sent[j])</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> pair <span class="keyword">not</span> <span class="keyword">in</span> token_pairs:</span><br><span class="line">                        token_pairs.append(pair)</span><br><span class="line">        <span class="keyword">return</span> token_pairs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">symmetrize</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> matrix + matrix.T - np.diag(matrix.diagonal())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_matrix</span><span class="params">(self, vocab, token_pairs)</span>:</span></span><br><span class="line">        vocab_size = len(vocab)</span><br><span class="line"></span><br><span class="line">        g = np.zeros((vocab_size, vocab_size), dtype=<span class="string">'float'</span>)</span><br><span class="line">        <span class="keyword">for</span> word1, word2 <span class="keyword">in</span> token_pairs:</span><br><span class="line">            i, j = vocab[word1], vocab[word2]</span><br><span class="line">            g[i][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        g = self.symmetrize(g)</span><br><span class="line"></span><br><span class="line">        sum = np.sum(g, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        np.divide(x1, x2, where=True)</span></span><br><span class="line"><span class="string">        x1: array_like 被除矩阵</span></span><br><span class="line"><span class="string">        x2: array_like 除数矩阵</span></span><br><span class="line"><span class="string">        如果x1和x2的shape不一致的话，他们必须符合数组广播规则，也就是输出矩阵的shape</span></span><br><span class="line"><span class="string">        -- 换言之，输入数组必须具有相同的形状或符合数组广播规则</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        g_after_divide = np.divide(g, sum, where=sum!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g_after_divide</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_keywords</span><span class="params">(self, num=<span class="number">10</span>)</span>:</span></span><br><span class="line">        node_weight = OrderedDict(sorted(self.node_weight.items(), key= <span class="keyword">lambda</span> t: t[<span class="number">1</span>], reverse=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, (k, v) <span class="keyword">in</span> enumerate(node_weight.items()):</span><br><span class="line">            print(k, <span class="string">" -- "</span>, v)</span><br><span class="line">            <span class="keyword">if</span> i &gt; num:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">analyze</span><span class="params">(self, doc, window_size=<span class="number">4</span>, candidate_pos=[<span class="string">'NOUN'</span>, <span class="string">'PROPN'</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                lower=False, stopwords=list<span class="params">()</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.set_stopwords(stopwords)</span><br><span class="line">        doc_sentences = self.sentence_segment(doc, candidate_pos, lower)</span><br><span class="line">        doc_vocab = self.get_vocab(doc_sentences)</span><br><span class="line">        doc_token_pairs = self.get_token_pairs(window_size, doc_sentences)</span><br><span class="line">        doc_matrix = self.get_matrix(doc_vocab, doc_token_pairs)</span><br><span class="line"></span><br><span class="line">        vocab_size = len(doc_vocab)</span><br><span class="line">        tr = np.array([<span class="number">1</span>] * vocab_size)</span><br><span class="line">        previous_tr = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.steps):</span><br><span class="line">            tr = <span class="number">1</span>-self.d + self.d * np.dot(doc_matrix, tr)</span><br><span class="line">            <span class="keyword">if</span> abs(previous_tr - sum(tr)) &lt; self.min_diff:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            previous_tr = sum(tr)</span><br><span class="line"></span><br><span class="line">        node_weight = dict()</span><br><span class="line">        <span class="keyword">for</span> word, index <span class="keyword">in</span> doc_vocab.items():</span><br><span class="line">            node_weight[word] = tr[index]</span><br><span class="line"></span><br><span class="line">        self.node_weight = node_weight</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    textrank = KeywordExtraction()</span><br><span class="line">    text = <span class="string">'''</span></span><br><span class="line"><span class="string">       The Wandering Earth, described as China’s first big-budget science fiction thriller, quietly made it onto screens at AMC theaters in North America this weekend, and it shows a new side of Chinese filmmaking — one focused toward futuristic spectacles rather than China’s traditionally grand, massive historical epics. At the same time, The Wandering Earth feels like a throwback to a few familiar eras of American filmmaking. While the film’s cast, setting, and tone are all Chinese, longtime science fiction fans are going to see a lot on the screen that reminds them of other movies, for better or worse.</span></span><br><span class="line"><span class="string">       '''</span></span><br><span class="line">    doc = nlp(text)</span><br><span class="line">    textrank.analyze(doc, <span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 取前10个权值最高的单词</span></span><br><span class="line">    textrank.get_keywords(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TextRank </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python正则表达式-不完全使用指南</title>
      <link href="/2019/07/22/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%8D%E5%AE%8C%E5%85%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2019/07/22/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%8D%E5%AE%8C%E5%85%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础字符"><a href="#1-基础字符" class="headerlink" title="1. 基础字符"></a>1. 基础字符</h1><h2 id="1-1-元字符"><a href="#1-1-元字符" class="headerlink" title="1.1 元字符"></a>1.1 元字符</h2><p>元字符是一些特殊的metacharactes， 并且不匹配自己。相反，他们表示应该匹配一些与众不同的东西，或者通过重复他们或改变他们的含义来影响正则的其他部分。元字符如下：</p><blockquote><p>.  ^  $  *  +  ?  {  }  [  ]  \  |  (  )</p></blockquote><ol><li>在元字符”[ ]”中，可以单独列出字符，也可以通过给出两个字符并用”-“标记将它们分开来表示一系列字符。例如，[abc]将匹配任何字符a、b或c（匹配单个字符），这与[a-c]相同，它使用一个范围来表示同一组字符。</li><li>字符类中的元字符不生效。例如，[akm$]将匹配’a’, ‘k’, ‘m’, ‘$’中的任意字符; ‘$’通常是一个元字符，但在一个字符类中它被剥夺了特殊性。</li></ol><h2 id="1-2-预定义字符集"><a href="#1-2-预定义字符集" class="headerlink" title="1.2 预定义字符集"></a>1.2 预定义字符集</h2><ul><li><code>\d</code> 匹配任何十进制数字；这等价于<code>[0-9]</code></li><li><code>\D</code> 匹配任何非数字字符；这等价于<code>[^0-9]</code></li><li><code>\s</code> 匹配任何空白字符；这等价于<code>[ \t\n\r\f\v]</code> </li><li><code>\S</code> 匹配任何非空白字符；这等价于<code>[^ \t\n\r\f\v]</code></li><li><code>\w</code> 匹配任何字母与数字字符；这相当于类<code>[a-zA-Z0-9]</code></li><li><code>\W</code> 匹配任何非字母与数字字符；这相当于类<code>[^a-zA-Z0-9]</code></li></ul><h2 id="1-3-常用操作符"><a href="#1-3-常用操作符" class="headerlink" title="1.3 常用操作符"></a>1.3 常用操作符</h2><div class="table-container"><table><thead><tr><th>操作符</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>.</td><td>表示任意单个字符</td><td>对于大小写字母、各种符号都能匹配</td></tr><tr><td>[  ]</td><td>字符集，对单个字符给出取值范围</td><td>[abc]表示a、b、c,[a-z]表示a到z的单个字符</td></tr><tr><td><sup><a href="#fn_  " id="reffn_  ">  </a></sup></td><td>非字符集，对单个字符给出排除范围</td><td><sup><a href="#fn_abc " id="reffn_abc ">abc </a></sup>表示非a或b或c的单个字符</td></tr><tr><td>*</td><td>前一个字符0次或无限次扩展</td><td>abc*表示ab、abc、abcc、abccc等</td></tr><tr><td>+</td><td>前一个字符1次或无限次扩展</td><td>abc+表示abc、abcc、abccc等</td></tr><tr><td>？</td><td>前一个字符0次或1次扩展</td><td>abc？表示ab、abc</td></tr><tr><td>\</td><td></td><td>左右表达式任意一个</td><td>abc\</td><td>def表示abc、def</td></tr><tr><td>{m}</td><td>扩展前一个字符m次</td><td>ab{2}c表示abbc</td></tr><tr><td>{m, n}</td><td>扩展前一个字符m至n次（包  含n）</td><td>ab{1, 2}表示ab、abb</td></tr><tr><td>^</td><td>匹配字符串开头</td><td>^abc表示abc且在一个字符串的开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td><td>abc$表示abc且在一个字符串的结尾</td></tr><tr><td>( )</td><td>分组标记，内部只能使用 \</td><td>操作符</td><td>(abc)表示abc，(abc \</td><td>def)表示abc、def</td></tr><tr><td>\d</td><td>表示十进制数字</td><td></td></tr><tr><td>\w</td><td>匹配任何字母与数字字符</td><td>相当于[a-zA-Z0-9]</td></tr></tbody></table></div><blockquote><p>tips:</p><ol><li>?字符可以看作是一个可选字符，如home-?grew，其表示home-grew或者homegrew，即当作 ? 的前一个字符是可选的的；</li><li>对于{m, n}来说，如果不限定m和n的数值，即{ , }，则认为下限m的值为0，而上限n的值则为无穷，因此：<ul><li>*也就等价于{0, }</li><li>+也就等价于{1, }</li><li>?也就等价于{0, 1}</li><li>但在实际中，还是建议使用*、+、?的形式，这样更短更容易阅读</li></ul></li></ol></blockquote><h1 id="2-使用正则表达式"><a href="#2-使用正则表达式" class="headerlink" title="2. 使用正则表达式"></a>2. 使用正则表达式</h1><p>有了前面的基础字符知识，我们已经可以使用正则表达式了，在python中如何使用它们呢？re模块提供了正则表达式引擎的接口，允许你将正则编译为对象，然后用它们进行匹配。</p><h2 id="2-1-编译正则表达式"><a href="#2-1-编译正则表达式" class="headerlink" title="2.1 编译正则表达式"></a>2.1 编译正则表达式</h2><p>正则表达式首先要编译成模式对象，然后才能进行各种操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re_pattern = re.compile(<span class="string">'ab*'</span>)</span><br><span class="line">print(<span class="string">"re_pattern : "</span>,re_pattern)</span><br><span class="line">print(<span class="string">"type :"</span>, type(re_pattern))</span><br><span class="line"></span><br><span class="line">[output]</span><br><span class="line">re_pattern :  re.compile(<span class="string">'ab*'</span>)</span><br><span class="line">type : &lt;<span class="class"><span class="keyword">class</span> '<span class="title">re</span>.<span class="title">Pattern</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>需要明确的是，正则是作为字符串传递给re.compile()的，正则被处理为字符串，因为正则表达式不是核心python语言的一部分，并且没有创建用于表达它们的特殊语法。</p><p>可以理解的是，在正则被re模块编译之前，它就是一个普通的字符串，这与python语言所理解的字符串并无二致，如前所述，正则表达式使用反斜杠字符 \ 来表示特殊形式或允许使用特殊字符而不调用它们的特殊含义，这就会与python字符串中的反斜杠用途发生冲突，导致反斜杠灾难。</p><blockquote><p>例如我们要编写一个与 \expression相匹配的正则，那么编译之后得到的目标模式就应该是  \ \expression，在编译之前，正则就是一个普通的字符串，对于每一个 \，在字符串中表示就是 \ \，也就是说，编译前的字符串就应该是 \ \ \ \ expression，可见，对目标字符串中如果有一个反斜杠，那么传给编译器的正则表达式中就会有4个反斜杠，十分繁琐。</p><div class="table-container"><table><thead><tr><th>字符</th><th>阶段</th></tr></thead><tbody><tr><td>\expression</td><td>被匹配的字符串</td></tr><tr><td>\ \ expression</td><td>为 re.compile()转义的反斜杠</td></tr><tr><td>“\\\\expression”</td><td>为字符串字面转义的反斜杠</td></tr></tbody></table></div><p>解决方案是使用python的原始字符串表示法来表示正则表达式；反斜杠不以任何特殊的方式处理前缀为 ‘r’的字符串字面，因此 r’\n’ 是一个包含 ‘\’和 ‘n’的双字符字符串，而 ‘\n’是一个包含换行符的单字符字符串。正则表达式通常使用这种原始字符串表示法用python代码编写。</p><div class="table-container"><table><thead><tr><th>常规字符串</th><th>原始字符串</th></tr></thead><tbody><tr><td>“ab*”</td><td>r”ab*”</td></tr><tr><td>“\\\\expression”</td><td>r”\\expression”</td></tr><tr><td>“\\w+\\s+\\l”</td><td>r”\w+\s+\l”</td></tr></tbody></table></div><p>tips:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment"># 带反斜杠的特殊字符可以用\d或者\\d来匹配</span></span><br><span class="line">&gt; pattern = re.compile(<span class="string">"\\d"</span>)</span><br><span class="line">&gt; result = pattern.findall(<span class="string">"space hh99"</span>)</span><br><span class="line">&gt; print(result)</span><br><span class="line">&gt; </span><br><span class="line">&gt; [output] : [<span class="string">'9'</span>, <span class="string">'9'</span>]</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment"># 匹配一个反斜杠</span></span><br><span class="line">&gt; pattern = re.compile(<span class="string">"\\\\"</span>)</span><br><span class="line">&gt; result = pattern.findall(<span class="string">"n\\b\\a"</span>)</span><br><span class="line">&gt; print(result)</span><br><span class="line">&gt; </span><br><span class="line">&gt; [output] : [<span class="string">'\\'</span>, <span class="string">'\\'</span>]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h1 id="3-应用匹配"><a href="#3-应用匹配" class="headerlink" title="3. 应用匹配"></a>3. 应用匹配</h1><h2 id="3-1-re库的常用函数"><a href="#3-1-re库的常用函数" class="headerlink" title="3.1 re库的常用函数"></a>3.1 re库的常用函数</h2><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>search()</td><td>扫描字符串，查找此正则匹配的任何位置，返回match对象</td></tr><tr><td>match()</td><td>从一个字符串的开始位置其匹配正则表达式，返回match对象</td></tr><tr><td>findall()</td><td>搜索字符串，以列表类型返回全部能匹配的子串</td></tr><tr><td>split()</td><td>将一个字符串按照正则表达式匹配结果进行分割，返回列表类型</td></tr><tr><td>finditer()</td><td>搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象</td></tr><tr><td>sub()</td><td>在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串</td></tr></tbody></table></div><h2 id="3-2-匹配对象"><a href="#3-2-匹配对象" class="headerlink" title="3.2 匹配对象"></a>3.2 匹配对象</h2><div class="table-container"><table><thead><tr><th>方法/属性</th><th>目的</th></tr></thead><tbody><tr><td>group()</td><td>返回正则匹配的字符串</td></tr><tr><td>start()</td><td>返回匹配的开始位置</td></tr><tr><td>end()</td><td>返回匹配的结束位置</td></tr><tr><td>span()</td><td>返回包含匹配(start, end)位置的元组</td></tr></tbody></table></div><p>group()返回正则匹配的子字符串。start()和end()返回匹配的其实和结束索引。span()在单个元组中返回开始和结束索引。由于match()方法只检查正则是否在字符串的开头匹配，所以start()将始终为0。</p><blockquote><p>注意：</p><p>只有match对象才有上述属性，也就是说，对一个模式只有使用search()、match()和finditer()后所返回的match对象才有上述属性，而对于使用findall()等方法，由于其返回对象是一个list，所以没有上述属性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">result1 = pattern.match(<span class="string">"little boy found his favorite toy"</span>)</span><br><span class="line">result2 = pattern.match(<span class="string">"littleboyfoundhisfavoritetoy"</span>)</span><br><span class="line">print(result1)</span><br><span class="line">print(result2)</span><br><span class="line"></span><br><span class="line">[output]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">6</span>), match=<span class="string">'little'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">28</span>),        match=<span class="string">'littleboyfoundhisfavoritetoy'</span>&gt;</span><br><span class="line"></span><br><span class="line">result2.group()</span><br><span class="line">[output]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'littleboyfoundhisfavoritetoy'</span></span><br><span class="line"></span><br><span class="line">result2.start()</span><br><span class="line">[output]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span></span><br><span class="line"></span><br><span class="line">result2.end()</span><br><span class="line">[output]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">28</span></span><br><span class="line"></span><br><span class="line">result2.span()</span><br><span class="line">[output]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">0</span>, <span class="number">28</span>)</span><br></pre></td></tr></table></figure><p>但是，模式的search()方法会扫描字符串，因此在这种情况下匹配可能不会从0开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">result3 = pattern.search(<span class="string">"****little boy`s here"</span>)</span><br><span class="line">result3.group()</span><br><span class="line">[output]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'little'</span></span><br><span class="line"></span><br><span class="line">result3.start()</span><br><span class="line">[output]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br><span class="line"></span><br><span class="line">result3.end()</span><br><span class="line">[output]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span></span><br><span class="line"></span><br><span class="line">result3.span()</span><br><span class="line">[output]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">4</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h1 id="4-更多模式能力"><a href="#4-更多模式能力" class="headerlink" title="4. 更多模式能力"></a>4. 更多模式能力</h1><h2 id="4-1-分组"><a href="#4-1-分组" class="headerlink" title="4.1 分组"></a>4.1 分组</h2><p>通常，你需要获取更多信息，而不仅仅是正则是否匹配。正则表达式通常用于通过将正则分成几个子组来解析字符串，这些子组匹配不同的感兴趣组件。</p><p>例如，现有如下信息：</p><blockquote><p>From: author@example.com</p><p>User-Agent: Thunderbird</p><p>MIME-Version: 1.0</p><p>To: editor@example</p></blockquote><p>我们想要提取每一个 ：后面的信息，因此可以使用分组来进行匹配，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># e.g. 4.1.1</span></span><br><span class="line"></span><br><span class="line">info = <span class="string">"From: author@example.com\nUser-Agent: Thunderbird\nMIME-Version: 1.0\nTo: editor@example"</span></span><br><span class="line"></span><br><span class="line">print(info)</span><br><span class="line">[output]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">From: author@example.com</span><br><span class="line">User-Agent: Thunderbird</span><br><span class="line">MIME-Version: <span class="number">1.0</span></span><br><span class="line">To: editor@example</span><br><span class="line"></span><br><span class="line">pattern1 = re.compile(<span class="string">r"From:\s+(\w+.\w+.\w+)\s+User-Agent:\s+(\w+)\s+MIME-Version:\s+(\d+.\d+)\s+To:\s+(\w+.\w+)"</span>, re.IGNORECASE)</span><br><span class="line"></span><br><span class="line">result = pattern1.findall(info)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">[output]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[(<span class="string">'author@example.com'</span>, <span class="string">'Thunderbird'</span>, <span class="string">'1.0'</span>, <span class="string">'editor@example'</span>)]</span><br><span class="line"></span><br><span class="line">result1 = pattern1.finditer(info)</span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> result1:</span><br><span class="line">    result.group(<span class="number">1</span>)</span><br><span class="line">    result.group(<span class="number">2</span>)</span><br><span class="line">    result.group(<span class="number">3</span>)</span><br><span class="line">    result.group(<span class="number">4</span>)</span><br><span class="line">   </span><br><span class="line">Out[<span class="number">108</span>]: <span class="string">'author@example.com'</span></span><br><span class="line">Out[<span class="number">108</span>]: <span class="string">'Thunderbird'</span></span><br><span class="line">Out[<span class="number">108</span>]: <span class="string">'1.0'</span></span><br><span class="line">Out[<span class="number">108</span>]: <span class="string">'editor@example'</span></span><br></pre></td></tr></table></figure><p>再上述4.1.1的例子中，我们在模式中写了四个分组，分别匹配From、User-Agent、MIME-Version和To后面的内容，这四个分组被自动地编号，分别为1、2、3、4，同时被捕获到了相应的内存中，这就引入了分组的后向引用，例如，我要进行一个双词的匹配，请看下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#e.g. 4.1.2</span></span><br><span class="line"></span><br><span class="line">raw = <span class="string">"loving loving can hurt"</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">在匹配之前，(\w+)这个分组可以匹配任何单词内容，一旦当这个分组匹配完毕，在这里，一开始就匹配了loving这个单词，因此，就把loving捕获，放在分组1的内存单元，再经过一个空格后，把分组1中的捕获内容取出，与当前单词比较，看是否匹配，如果匹配，则结束，否则，重新匹配这个分组。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">pattern = re.compile(<span class="string">r"\b(\w+)\b\s+\1"</span>)</span><br><span class="line">print(pattern.findall(raw))</span><br><span class="line"></span><br><span class="line">[output]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">[<span class="string">'loving'</span>]</span><br></pre></td></tr></table></figure><h2 id="4-2-忽略某个分组"><a href="#4-2-忽略某个分组" class="headerlink" title="4.2 忽略某个分组"></a>4.2 忽略某个分组</h2><p>有时候给正则的某个子表达式加括号并不是为了分组，而仅仅是为了看起来更清晰，因此我们并不需要捕获该分组，那么，可以使用(?:expression)来忽略该分组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># e.g. 4.2.1</span></span><br><span class="line">raw = <span class="string">"age:13, name:Tom"</span></span><br><span class="line">pattern = re.compile(<span class="string">r"age.(\d+).\s*name.(\w+)"</span>)</span><br><span class="line"></span><br><span class="line">print(pattern.findall(raw))</span><br><span class="line">[out]: [(<span class="string">'13'</span>, <span class="string">'Tom'</span>)]</span><br><span class="line"></span><br><span class="line">print(pattern.search(raw).group(<span class="number">1</span>))</span><br><span class="line">[out]: <span class="number">13</span></span><br><span class="line">    </span><br><span class="line">print(pattern.search(raw).group(<span class="number">2</span>))</span><br><span class="line">[out]: Tom</span><br><span class="line">    </span><br><span class="line">pattern1 = re.compile(<span class="string">r"age.(\d+).\s*name.(?:\w+)"</span>)</span><br><span class="line">print(pattern1.findall(raw))</span><br><span class="line">[out]: [<span class="string">'13'</span>]</span><br><span class="line">print(pattern1.search(raw).group(<span class="number">1</span>))</span><br><span class="line">[out]: <span class="number">13</span></span><br><span class="line"><span class="comment"># 由于忽略了第二个分组，因此无法检索该分组</span></span><br><span class="line">print(pattern1.search(raw).group(<span class="number">2</span>))</span><br><span class="line">[out]: IndexError: no such group</span><br></pre></td></tr></table></figure><p>需要注意的是，除了你无法检索组匹配内容的事实外，非捕获组的行为与捕获组完全相同；你可以在里面放任何东西，用重复元字符重复它，比如*，燃火把它嵌入其他组（捕获或不捕获）。<font color="red">(?:…..)在修改现有模式的时候特别有用，因为你可以添加新组而不更改所有其他组的编号方式。</font><font color="blue">红色部分不懂什么意思。</font>值得一提的是，捕获和非捕获组之间的搜索没有性能差异，两种形式没有哪一种更快。</p><h2 id="4-3-命名分组"><a href="#4-3-命名分组" class="headerlink" title="4.3 命名分组"></a>4.3 命名分组</h2><p>命名组的语法是python特定的扩展之一：(?P<name>…)。name是该分组的名称。命名组的行为与捕获组完全相同，并且还将名称与组关联。处理捕获组的的匹配对象方法都接受 1. 按编号引用该分组；2. 按组名字符串引用该分组。</name></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">raw = <span class="string">"sheeran sheeran is good"</span></span><br><span class="line">pattern = re.compile(<span class="string">r"(?P&lt;name&gt;\b\w+\b)\s+(?P=name)"</span>)</span><br><span class="line">print(pattern.findall(raw))</span><br><span class="line"></span><br><span class="line">[out]: [<span class="string">'sheeran'</span>]</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">r"(?P&lt;name&gt;\b\w+\b)\s+\1"</span>)</span><br><span class="line">print(pattern.findall(raw))</span><br><span class="line"></span><br><span class="line">[out]: [<span class="string">'sheeran'</span>]</span><br></pre></td></tr></table></figure><h2 id="4-4-前向断言"><a href="#4-4-前向断言" class="headerlink" title="4.4 前向断言"></a>4.4 前向断言</h2><p>另一个零宽度断言是前向断言。前向断言以正面和负面形式提供，如下所示：</p><ol><li><h4 id="正前向断言-—-…"><a href="#正前向断言-—-…" class="headerlink" title="正前向断言  —  (?=…)"></a>正前向断言  —  (?=…)</h4><p>如果包含的正则表达式，由<code>...</code>表示，在当前位置成功匹配，则成功，否则失败。但是，一旦尝试了包含的表达式，匹配的引擎就不会前进，模式其余的部分会在断言开始的地方尝试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选出得分大于30分的球员</span></span><br><span class="line">raw = [<span class="string">"James:36.33"</span>, <span class="string">"Bryant:33.2"</span>, <span class="string">"ONeal:24.33"</span>]</span><br><span class="line">pattern = re.compile(<span class="string">r".+(?=[:][3][0-9][.][0-9]+)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> raw:</span><br><span class="line">    print(pattern.findall(it))</span><br><span class="line">    </span><br><span class="line">[out]: [<span class="string">'James'</span>]</span><br><span class="line">   [<span class="string">'Bryant'</span>]</span><br><span class="line">   []</span><br></pre></td></tr></table></figure></li></ol><ol><li><h4 id="负前向断言-—-…"><a href="#负前向断言-—-…" class="headerlink" title="负前向断言  —  (?!…)"></a>负前向断言  —  (?!…)</h4><p>如果包含的表达式在字符串中的当前位置不匹配，则成功。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">现有一些文件如下：</span></span><br><span class="line"><span class="string">["sample.txt", "ss.batch", "text.bat", "computer.sss", "name.is.wiki", "haha.bat.ten", "start.end.bat"]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们需要从中选取出后缀不是bat的文件，因此可以使用负前向断言来匹配后缀不是bat的文件</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">raw = [<span class="string">"sample.txt"</span>, <span class="string">"ss.batch"</span>, <span class="string">"text.bat"</span>, <span class="string">"computer.sss"</span>, <span class="string">"name.is.wiki"</span>, <span class="string">"haha.bat.ten"</span>, <span class="string">"start.end.bat"</span>]</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">r".*[.](?!bat$)[^.]*"</span>)</span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> raw:</span><br><span class="line">    print(pattern.findall(it))</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">[out]: [<span class="string">'sample.txt'</span>]</span><br><span class="line">   [<span class="string">'ss.batch'</span>]</span><br><span class="line">       []</span><br><span class="line">       [<span class="string">'computer.sss'</span>]</span><br><span class="line">       [<span class="string">'name.is.wiki'</span>]</span><br><span class="line">       [<span class="string">'haha.bat.ten'</span>]</span><br><span class="line">       []</span><br></pre></td></tr></table></figure><p>在上述代码中，模式是<code>r&quot;.*[.](?!bat$)[^.]*&quot;</code>，意思是，从结尾匹配bat，如果匹配，则该模式失败，如果结尾不匹配bat，那么开始匹配模式<code>[^.]*$</code>。也就是说，如果结尾不匹配bat，我们使用<code>[^.]*$</code> 就可以把不匹配的后缀部分输出。如果我们使用的模式是<code>r&quot;.*[.](?!bat$)</code>，那么就相当于把后缀不是bat的<code>.*[.]</code> 输出，即只是输出后缀前面的部分:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">raw = [<span class="string">"sample.txt"</span>, <span class="string">"ss.batch"</span>, <span class="string">"text.bat"</span>, <span class="string">"computer.sss"</span>, <span class="string">"name.is.wiki"</span>, <span class="string">"haha.bat.ten"</span>]</span><br><span class="line"></span><br><span class="line">pattern = re.compile(<span class="string">r".*[.](?!bat$)"</span>)</span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> raw:</span><br><span class="line">    print(pattern.findall(it))</span><br><span class="line">    </span><br><span class="line">[out]: [<span class="string">'sample.'</span>]</span><br><span class="line">   [<span class="string">'ss.'</span>]</span><br><span class="line">   []</span><br><span class="line">   [<span class="string">'computer.'</span>]</span><br><span class="line">   [<span class="string">'name.is.'</span>]</span><br><span class="line">   [<span class="string">'haha.bat.'</span>]</span><br></pre></td></tr></table></figure><blockquote><p>tips:</p><p>在平常使用中，更感觉前向断言像是一个筛选条件，我们可以匹配一个字符或字符串，在匹配对象的后面或者前面我们设定一些条件，可以用前向断言来实现。</p></blockquote></li></ol><h1 id="5-修改字符串"><a href="#5-修改字符串" class="headerlink" title="5. 修改字符串"></a>5. 修改字符串</h1><p>到目前为止，我们只是针对静态字符串执行搜索。正则表达式通常也用于以各种方式修改字符串，使用以下模式方法：</p><div class="table-container"><table><thead><tr><th>方法/属性</th><th>目的</th></tr></thead><tbody><tr><td>split()</td><td>将字符串拆分成一个列表，在正则匹配的任何地方将其拆分</td></tr><tr><td>sub()</td><td>找到正则匹配的所有子字符串，并用不同的字符串替换它们</td></tr><tr><td>subn()</td><td>与sub()相同，但返回新字符串和替换次数</td></tr></tbody></table></div><h2 id="5-1-分割字符串"><a href="#5-1-分割字符串" class="headerlink" title="5.1 分割字符串"></a>5.1 分割字符串</h2><p>模式的split()方法在正则匹配的任何地方拆分字符串，返回一个片段列表。它有两种使用方式：</p><ul><li><code>pattern.split(string [, maxsplit = 0])</code></li><li><code>re.split(pattern, string [, maxsplit = 0])</code></li></ul><p>通过正则表达式的匹配拆分字符串，如果在正则中使用捕获括号，则它们的内容也将作为结果列表的一部分返回。如果maxsplit非零，则最多执行maxsplit次拆分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分隔符是任意非字母数字字符序列</span></span><br><span class="line">p = re.compile(<span class="string">r"\W+"</span>)</span><br><span class="line"><span class="comment"># 不设定maxsplit</span></span><br><span class="line">result1 = p.split(<span class="string">"this is a test, short and sweet, of split()"</span>)</span><br><span class="line">print(result1)</span><br><span class="line"></span><br><span class="line">[out]:  [<span class="string">'this'</span>, <span class="string">'is'</span>, <span class="string">'a'</span>, <span class="string">'test'</span>, <span class="string">'short'</span>, <span class="string">'and'</span>, <span class="string">'sweet'</span>, <span class="string">'of'</span>, <span class="string">'split'</span>, <span class="string">''</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定maxsplit = 3，则最多在字符串上分隔3次</span></span><br><span class="line">result2 = p.split(<span class="string">"this is a test, short and sweet, of split()"</span>, maxsplit = <span class="number">3</span>)</span><br><span class="line">print(result2)</span><br><span class="line"></span><br><span class="line">[out]:  [<span class="string">'this'</span>, <span class="string">'is'</span>, <span class="string">'a'</span>, <span class="string">'test, short and sweet, of split()'</span>]</span><br></pre></td></tr></table></figure><p>如果我们不单单想要根据分隔符分隔出的文本，而且还需要知道分隔符是什么，因此，如果在正则中使用捕获括号，则分隔符的内容也会作为列表的一部分返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在这一句中，分隔符是“， ”</span></span><br><span class="line">re.split(<span class="string">r"([\W]+)"</span>, <span class="string">"words, words, words"</span>)</span><br></pre></td></tr></table></figure><h2 id="5-2-搜索和替换"><a href="#5-2-搜索和替换" class="headerlink" title="5.2 搜索和替换"></a>5.2 搜索和替换</h2><p>另一个常见任务是找到模式的所有匹配项，并用不同的字符串替换它们。sub()方法接受一个替换值，可以是字符串或函数，也可以是要处理的字符串。</p><ul><li><code>pattern.sub(replacement, string[, count = 0])</code></li></ul><ol><li>使用replacement来替换string中的匹配对象，如果没有找到模式，则string将保持不变。</li><li>可选参数count是要替换的模式最大出现次数，count必须是非负整数。默认为0表示替换所有。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">raw = <span class="string">"sheeran is a good singer, and I think sheeran is awesome!"</span></span><br><span class="line">pattern = re.compile(<span class="string">r"sheeran"</span>)</span><br><span class="line">pattern.sub(<span class="string">"jay"</span>, raw)</span><br><span class="line"></span><br><span class="line">[out]:  </span><br><span class="line"><span class="string">'jay is a good singer, and I think jay is awesome!'</span></span><br><span class="line"></span><br><span class="line">pattern.sub(<span class="string">"Jay"</span>, raw, count = <span class="number">1</span>)</span><br><span class="line">[out]:</span><br><span class="line">    <span class="string">'Jay is a good singer, and I think sheeran is awesome!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># subn的用法和sub一致，但返回一个包含新字符串值和一致性的替换次数的2元组。    </span></span><br><span class="line">pattern.subn(<span class="string">"Jay"</span>, raw)</span><br><span class="line">[out]:</span><br><span class="line">    (<span class="string">'Jay is a good singer, and I think Jay is awesome!'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，如果replacement是一个字符串，则处理其中的任何反斜杠转义。也就是说，<code>\n</code>被转换为单个换行符，<code>\r</code> 被转换为回车符，依此类推。</p><p>还有一种语法用于引用由<code>(?P&lt;name&gt;...)</code>语法定义的命名组。<code>\g&lt;name&gt;</code> 将使用名称为<code>name</code> 的组匹配的子字符串，<code>\g&lt;number&gt;</code> 使用相应的组号(后向引用)，因此<code>\g&lt;2&gt;</code> 等同于<code>\2</code> ，但在诸如<code>\g&lt;2&gt;0</code> 之类的替换字符串中并不模糊。而<code>\20</code> 则被解释为对组20捕获的内容惊醒引用，而不是对组2的引用，因此不建议使用<code>\20</code> 这种用法，以下几种用法都是等效的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">player = <span class="string">"James&#123;Forward&#125; Rondo&#123;Guard&#125; Cousins&#123;Center&#125;"</span></span><br><span class="line"></span><br><span class="line">p = re.compile(<span class="string">r"\w+&#123;(?P&lt;position&gt;[^&#125;]*)&#125;"</span>)</span><br><span class="line"><span class="comment"># 把所有匹配正则的子字符串替换成 player(\g&lt;position&gt;)</span></span><br><span class="line">p.sub(<span class="string">r"player(\g&lt;position&gt;)"</span>, player)</span><br><span class="line">[out]:</span><br><span class="line">    <span class="string">'player(Forward) player(Guard) player(Center)'</span></span><br><span class="line"></span><br><span class="line">p.sub(<span class="string">r"player(\g&lt;1&gt;)"</span>,player)</span><br><span class="line">[out]:</span><br><span class="line">    <span class="string">'player(Forward) player(Guard) player(Center)'</span></span><br><span class="line"></span><br><span class="line">p.sub(<span class="string">r"player(\1)"</span>, player)</span><br><span class="line">[out]:</span><br><span class="line">    <span class="string">'player(Forward) player(Guard) player(Center)'</span></span><br></pre></td></tr></table></figure><p>此外，replacement也可以是一个函数，它可以为你提供更多控制。如果replacement是一个函数，则为patter的每次非重叠出现将调用该函数。在每次调用时，函数都会传递一个匹配的匹配对象参数，并可以使用此信息计算所需的替换字符串并将其返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现将句中的正数转换为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(match)</span>:</span></span><br><span class="line">    value = int(match.group())</span><br><span class="line">    after_transfer = float(value)</span><br><span class="line">    <span class="comment"># 字符类型转换</span></span><br><span class="line">    <span class="keyword">return</span> str(after_transfer)</span><br><span class="line"></span><br><span class="line">raw = <span class="string">"James scored 33 points and Davis scored 29 points"</span></span><br><span class="line">p = re.compile(<span class="string">r"\d+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">需要注意的时，sub(replacement, string)，replacement一般都是一个字符型对象。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">p.sub(transfer, raw)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-0019-删除链表的倒数第N个个节点</title>
      <link href="/2019/06/04/leetcode-0019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>/2019/06/04/leetcode-0019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="题目表述"><a href="#题目表述" class="headerlink" title="[题目表述]"></a>[题目表述]</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><pre><code>    def removeNthFromEnd_one_iter(self, head, n):        dummy = ListNode(0)    dummy.next = head    first = dummy    second = dummy    while n &gt;= 0:        first = first.next        n -= 1    while first:        second = second.next        first = first.next    second.next = second.next.next    return dummy.next</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
